<!doctype html>
<html>
  <head>
    <meta
      http-equiv="Content-Security-Policy"
      content="default-src 'none'; script-src 'unsafe-inline'; style-src 'unsafe-inline'"
    />
    <title>Enclave Outer Sandbox</title>
  </head>
  <body>
    <script>
      'use strict';
      (function () {
        var requestId = '4ccc7a32-bd28-4db5-811d-2ea209be9e6b';
        var aborted = false;
        var completed = false;

        // ============================================================
        // Safe Error
        // ============================================================
        function createSafeError(message, name) {
          var error = new Error(message);
          error.name = name || 'Error';
          try {
            Object.setPrototypeOf(error, null);
          } catch (e) {}
          try {
            Object.freeze(error);
          } catch (e) {}
          return error;
        }

        // ============================================================
        // Validation Configuration
        // ============================================================
        var validationConfig = {
          validateOperationNames: true,
          maxOperationsPerSecond: 100,
          blockSuspiciousSequences: true,
          rapidEnumerationThreshold: 30,
          rapidEnumerationOverrides: {},
        };

        // Suspicious pattern detectors
        var suspiciousPatterns = [
          {
            id: 'EXFIL_LIST_SEND',
            description: 'List/query followed by send/export (potential exfiltration)',
            detect: function (operationName, args, history) {
              var recentQueries = history.filter(function (h) {
                return (
                  /list|query|get|fetch|read|search|find|select/i.test(h.operationName) &&
                  Date.now() - h.timestamp < 5000
                );
              });
              var isSendOperation = /send|export|post|write|upload|publish|emit|transmit|forward/i.test(operationName);
              return recentQueries.length > 0 && isSendOperation;
            },
          },
          {
            id: 'RAPID_ENUMERATION',
            description: 'Rapid enumeration of resources',
            detect: function (operationName, args, history) {
              var now = Date.now();
              var recentSame = history.filter(function (h) {
                return h.operationName === operationName && now - h.timestamp < 5000;
              });
              var threshold = 30;
              try {
                if (typeof validationConfig !== 'undefined') {
                  threshold =
                    (validationConfig.rapidEnumerationOverrides &&
                      validationConfig.rapidEnumerationOverrides[operationName]) ||
                    validationConfig.rapidEnumerationThreshold ||
                    30;
                }
              } catch (e) {
                threshold = 30;
              }
              return recentSame.length > threshold;
            },
          },
          {
            id: 'CREDENTIAL_EXFIL',
            description: 'Credential access followed by external operation',
            detect: function (operationName, args, history) {
              var recentCreds = history.filter(function (h) {
                return (
                  /secret|credential|password|token|key|auth|api[_-]?key/i.test(h.operationName) &&
                  Date.now() - h.timestamp < 10000
                );
              });
              var isExternal = /http|api|external|webhook|slack|email|sms|notification/i.test(operationName);
              return recentCreds.length > 0 && isExternal;
            },
          },
          {
            id: 'BULK_OPERATION',
            description: 'Bulk/batch operation detected',
            detect: function (operationName, args, history) {
              var isBulk = /\b(bulk|batch|mass|dump)\b|export[_-]all\b/i.test(operationName);
              if (typeof args === 'object' && args !== null) {
                try {
                  var argStr = JSON.stringify(args).toLowerCase();
                  if (/limit.*[0-9]{4,}|"\*"|no[_-]?limit/i.test(argStr)) return true;
                } catch (e) {}
              }
              return isBulk;
            },
          },
          {
            id: 'DELETE_AFTER_ACCESS',
            description: 'Delete operation after data access (potential cover-up)',
            detect: function (operationName, args, history) {
              var isDelete = /delete|remove|destroy|purge|clear|wipe|erase/i.test(operationName);
              if (!isDelete) return false;
              var recentAccess = history.filter(function (h) {
                return (
                  /list|query|get|fetch|read|search|find|select/i.test(h.operationName) &&
                  Date.now() - h.timestamp < 30000
                );
              });
              return recentAccess.length > 0;
            },
          },
        ];

        // Operation history for pattern detection
        var operationHistory = [];

        // Tool call counter
        var toolCallCount = 0;

        // ============================================================
        // Validation Logic (ported from parent-vm-bootstrap.ts)
        // ============================================================
        function validateOperation(operationName, args) {
          var now = Date.now();

          // Sliding window cleanup
          while (operationHistory.length > 0 && now - operationHistory[0].timestamp > 2000) {
            operationHistory.shift();
          }

          // Rate limiting
          var recentOps = operationHistory.filter(function (h) {
            return now - h.timestamp < 1000;
          });
          if (recentOps.length >= validationConfig.maxOperationsPerSecond) {
            throw createSafeError(
              'Operation rate limit exceeded (' + validationConfig.maxOperationsPerSecond + ' operations/second)',
            );
          }

          // Name validation
          if (typeof operationName !== 'string' || !operationName) {
            throw createSafeError('Operation name must be a non-empty string', 'TypeError');
          }

          // Whitelist check
          if (validationConfig.validateOperationNames && typeof allowedOperationPattern !== 'undefined') {
            if (!allowedOperationPattern.test(operationName)) {
              throw createSafeError('Operation "' + operationName + '" does not match allowed pattern');
            }
          }

          // Blacklist check
          if (typeof blockedOperationPatterns !== 'undefined') {
            for (var i = 0; i < blockedOperationPatterns.length; i++) {
              if (blockedOperationPatterns[i].test(operationName)) {
                throw createSafeError('Operation "' + operationName + '" matches blocked pattern');
              }
            }
          }

          // Suspicious sequence detection
          if (validationConfig.blockSuspiciousSequences) {
            for (var j = 0; j < suspiciousPatterns.length; j++) {
              var pattern = suspiciousPatterns[j];
              var detected = false;
              try {
                detected = !!pattern.detect(operationName, args, operationHistory);
              } catch (e) {
                detected = false;
              }
              if (detected) {
                throw createSafeError('Suspicious pattern detected: ' + pattern.description + ' [' + pattern.id + ']');
              }
            }
          }
        }

        // ============================================================
        // Message Sending
        // ============================================================
        function sendToHost(msg) {
          msg.__enclave_msg__ = true;
          msg.requestId = requestId;
          try {
            window.parent.postMessage(msg, '*');
          } catch (e) {}
        }

        var innerFrame = null;

        function sendToInner(msg) {
          msg.__enclave_msg__ = true;
          msg.requestId = requestId;
          if (innerFrame && innerFrame.contentWindow) {
            try {
              innerFrame.contentWindow.postMessage(msg, '*');
            } catch (e) {}
          }
        }

        // ============================================================
        // Message Relay Logic (Three-Hop)
        // ============================================================
        window.addEventListener('message', function (event) {
          var data = event.data;
          if (!data || data.__enclave_msg__ !== true) return;
          if (completed) return;

          var fromInner = innerFrame && event.source === innerFrame.contentWindow;
          var fromHost = event.source === window.parent;
          if (data.requestId !== requestId) return;

          // Messages from inner iframe (tool-call, result, console)
          if (data.type === 'tool-call') {
            if (!fromInner) return;
            // Validate before forwarding to host
            try {
              // Double sanitize args
              var sanitizedArgs;
              try {
                sanitizedArgs = JSON.parse(JSON.stringify(data.args));
              } catch (e) {
                throw createSafeError('Tool arguments must be JSON-serializable');
              }

              toolCallCount++;
              validateOperation(data.toolName, sanitizedArgs);

              // Record in history
              operationHistory.push({
                operationName: data.toolName,
                timestamp: Date.now(),
                argKeys: sanitizedArgs && typeof sanitizedArgs === 'object' ? Object.keys(sanitizedArgs) : [],
              });

              // Forward validated tool call to host
              sendToHost({
                type: 'tool-call',
                callId: data.callId,
                toolName: data.toolName,
                args: sanitizedArgs,
              });
            } catch (error) {
              // Validation failed - send error back to inner as tool-response
              sendToInner({
                type: 'tool-response',
                callId: data.callId,
                error: {
                  name: error && error.name ? String(error.name) : 'ValidationError',
                  message: error && error.message ? String(error.message) : 'Validation failed',
                },
              });
            }
          } else if (data.type === 'result') {
            if (!fromInner) return;
            // Forward execution result to host
            completed = true;
            sendToHost({
              type: 'result',
              success: data.success,
              value: data.value,
              error: data.error,
              stats: data.stats,
            });
          } else if (data.type === 'console') {
            if (!fromInner) return;
            // Forward console output to host
            sendToHost({
              type: 'console',
              level: data.level,
              args: data.args,
            });
          } else if (data.type === 'tool-response') {
            if (!fromHost) return;
            // Message from host - forward tool response to inner
            sendToInner({
              type: 'tool-response',
              callId: data.callId,
              result: data.result,
              error: data.error,
            });
          } else if (data.type === 'abort') {
            if (!fromHost) return;
            // Abort from host - forward to inner and destroy it
            aborted = true;
            sendToInner({ type: 'abort' });
            // Remove inner iframe for hard termination
            if (innerFrame && innerFrame.parentNode) {
              innerFrame.parentNode.removeChild(innerFrame);
              innerFrame = null;
            }
          }
        });

        // ============================================================
        // Create Inner Iframe
        // ============================================================
        var innerHtml =
          "<!DOCTYPE html><html><head><meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'none'; script-src 'unsafe-inline'; style-src 'unsafe-inline'\"><title>Enclave Inner Sandbox<\/title><\/head><body><script>\"use strict\";\n(function() {\n  var requestId = \"4ccc7a32-bd28-4db5-811d-2ea209be9e6b\";\n  var aborted = false;\n  var startTime = Date.now();\n  var toolCallCount = 0;\n  var iterationCount = 0;\n  var consoleCalls = 0;\n  var consoleOutputBytes = 0;\n\n  // Pending tool call resolvers: callId -> { resolve, reject }\n  var pendingToolCalls = {};\n\n  // ============================================================\n  // Safe Error\n  // ============================================================\n  function createSafeError(message, name) {\n    var error = new Error(message);\n    error.name = name || 'Error';\n    try { Object.setPrototypeOf(error, null); } catch(e) {}\n    try {\n      Object.defineProperty(error, 'constructor', { value: null, writable: false, configurable: false, enumerable: false });\n      Object.defineProperty(error, '__proto__', { value: null, writable: false, configurable: false, enumerable: false });\n      Object.defineProperty(error, 'stack', { value: undefined, writable: false, configurable: false, enumerable: false });\n    } catch(e) {}\n    try { Object.freeze(error); } catch(e) {}\n    return error;\n  }\n\n  // ============================================================\n  // Secure Proxy\n  // ============================================================\n  var blockedPropertiesSet = new Set([\"__proto__\",\"prototype\",\"constructor\",\"__defineGetter__\",\"__defineSetter__\",\"__lookupGetter__\",\"__lookupSetter__\"]);\n  var proxyCache = new WeakMap();\n\n  function createSecureProxy(obj, depth) {\n    if (depth === undefined) depth = 0;\n    if (depth > 10) return obj;\n    if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) return obj;\n    if (proxyCache.has(obj)) return proxyCache.get(obj);\n\n    var proxy = new Proxy(obj, {\n      get: function(target, property, receiver) {\n        var propName = String(property);\n        var descriptor = Object.getOwnPropertyDescriptor(target, property);\n        var isNonConfigurable = descriptor && !descriptor.configurable;\n\n        if (descriptor && isNonConfigurable && 'value' in descriptor && descriptor.writable === false) {\n          return descriptor.value;\n        }\n\n        if (blockedPropertiesSet.has(propName)) {\n          if (isNonConfigurable) return Reflect.get(target, property, receiver);\n          throw createSafeError(\"Security violation: Access to '\" + propName + \"' is blocked.\");\n        }\n\n        var value = Reflect.get(target, property, receiver);\n        if (typeof value === 'function') {\n          var boundMethod = value.bind(target);\n          return createSecureProxy(boundMethod, depth + 1);\n        }\n        if (value !== null && typeof value === 'object') {\n          return createSecureProxy(value, depth + 1);\n        }\n        return value;\n      },\n      set: function(target, property, value, receiver) {\n        var propName = String(property);\n        if (blockedPropertiesSet.has(propName)) {\n          throw createSafeError(\"Security violation: Setting '\" + propName + \"' is blocked.\");\n        }\n        return Reflect.set(target, property, value, receiver);\n      },\n      getPrototypeOf: function() { return null; }\n    });\n\n    proxyCache.set(obj, proxy);\n    return proxy;\n  }\n\n  // ============================================================\n  // PostMessage Communication with Outer Iframe\n  // ============================================================\n  function sendToOuter(msg) {\n    msg.__enclave_msg__ = true;\n    msg.requestId = requestId;\n    try {\n      window.parent.postMessage(msg, '*');\n    } catch(e) { /* ignore */ }\n  }\n\n  // Listen for messages from outer iframe\n  window.addEventListener('message', function(event) {\n    var data = event.data;\n    if (!data || data.__enclave_msg__ !== true) return;\n\n    if (data.type === 'tool-response') {\n      var pending = pendingToolCalls[data.callId];\n      if (pending) {\n        delete pendingToolCalls[data.callId];\n        if (data.error) {\n          pending.reject(createSafeError(data.error.message, data.error.name));\n        } else {\n          pending.resolve(data.result);\n        }\n      }\n    } else if (data.type === 'abort') {\n      aborted = true;\n    }\n  });\n\n  // ============================================================\n  // Safe Runtime Functions\n  // ============================================================\n\n  // Generate unique call IDs\n  var callIdCounter = 0;\n  function generateCallId() {\n    return 'c-' + (++callIdCounter) + '-' + Date.now().toString(36) + '-' + Math.random().toString(36).slice(2, 8);\n  }\n\n  function __safe_callTool(toolName, args) {\n    if (aborted) throw createSafeError('Execution aborted');\n\n    toolCallCount++;\n    if (toolCallCount > 100) {\n      throw createSafeError('Maximum tool call limit exceeded (100).');\n    }\n\n    if (typeof toolName !== 'string' || !toolName) {\n      throw createSafeError('Tool name must be a non-empty string', 'TypeError');\n    }\n    if (typeof args !== 'object' || args === null || Array.isArray(args)) {\n      throw createSafeError('Tool arguments must be an object', 'TypeError');\n    }\n\n    // Double sanitization\n    var sanitizedArgs;\n    try { sanitizedArgs = JSON.parse(JSON.stringify(args)); }\n    catch(e) { throw createSafeError('Tool arguments must be JSON-serializable'); }\n\n    var callId = generateCallId();\n\n    return new Promise(function(resolve, reject) {\n      pendingToolCalls[callId] = { resolve: resolve, reject: reject };\n      sendToOuter({\n        type: 'tool-call',\n        callId: callId,\n        toolName: toolName,\n        args: sanitizedArgs\n      });\n    });\n  }\n\n  function* __safe_forOf(iterable) {\n    var iterations = 0;\n    for (var item of iterable) {\n      if (aborted) throw createSafeError('Execution aborted');\n      iterations++;\n      iterationCount++;\n      if (iterations > 10000) {\n        throw createSafeError('Maximum iteration limit exceeded (10000).');\n      }\n      yield item;\n    }\n  }\n\n  function __safe_for(init, test, update, body) {\n    var iterations = 0;\n    init();\n    while (test()) {\n      if (aborted) throw createSafeError('Execution aborted');\n      iterations++;\n      iterationCount++;\n      if (iterations > 10000) {\n        throw createSafeError('Maximum iteration limit exceeded (10000).');\n      }\n      body();\n      update();\n    }\n  }\n\n  function __safe_while(test, body) {\n    var iterations = 0;\n    while (test()) {\n      if (aborted) throw createSafeError('Execution aborted');\n      iterations++;\n      iterationCount++;\n      if (iterations > 10000) {\n        throw createSafeError('Maximum iteration limit exceeded (10000).');\n      }\n      body();\n    }\n  }\n\n  function __safe_doWhile(body, test) {\n    var iterations = 0;\n    do {\n      if (aborted) throw createSafeError('Execution aborted');\n      iterations++;\n      iterationCount++;\n      if (iterations > 10000) {\n        throw createSafeError('Maximum iteration limit exceeded (10000).');\n      }\n      body();\n    } while (test());\n  }\n\n  function __safe_concat(left, right) {\n    if (typeof left === 'number' && typeof right === 'number') return left + right;\n    var result = (left) + (right);\n    return result;\n  }\n\n  function __safe_template(quasis) {\n    var values = [];\n    for (var i = 1; i < arguments.length; i++) values.push(arguments[i]);\n    var result = quasis[0];\n    for (var j = 0; j < values.length; j++) {\n      result += String(values[j]) + quasis[j + 1];\n    }\n    return result;\n  }\n\n  function __safe_parallel(fns, options) {\n    if (!Array.isArray(fns)) throw createSafeError('parallel requires an array of functions', 'TypeError');\n    if (fns.length === 0) return Promise.resolve([]);\n    if (fns.length > 100) throw createSafeError('Cannot execute more than 100 operations in parallel.');\n\n    for (var i = 0; i < fns.length; i++) {\n      if (typeof fns[i] !== 'function') throw createSafeError('Item at index ' + i + ' is not a function', 'TypeError');\n    }\n\n    var concurrency = Math.min(Math.max(1, (options && options.maxConcurrency) || 10), 20);\n    var results = new Array(fns.length);\n    var errors = [];\n    var currentIndex = 0;\n\n    function runNext() {\n      return new Promise(function(resolve) {\n        function step() {\n          if (currentIndex >= fns.length) { resolve(); return; }\n          if (aborted) { resolve(); return; }\n          var index = currentIndex++;\n          Promise.resolve().then(function() { return fns[index](); }).then(function(result) {\n            results[index] = result;\n            step();\n          }).catch(function(error) {\n            errors.push({ index: index, error: error });\n            step();\n          });\n        }\n        step();\n      });\n    }\n\n    var workers = [];\n    for (var w = 0; w < Math.min(concurrency, fns.length); w++) workers.push(runNext());\n\n    return Promise.all(workers).then(function() {\n      if (errors.length > 0) {\n        var msgs = errors.map(function(e) { return '[' + e.index + ']: ' + (e.error && e.error.message || e.error); }).join('\\n');\n        throw createSafeError(errors.length + ' of ' + fns.length + ' parallel operations failed:\\n' + msgs);\n      }\n      return results;\n    });\n  }\n\n  // ============================================================\n  // Console Implementation (relayed via postMessage)\n  // ============================================================\n  var safeConsole = {};\n  ['log', 'warn', 'error', 'info'].forEach(function(level) {\n    safeConsole[level] = function() {\n      consoleCalls++;\n      if (consoleCalls > 1000) return;\n\n      var args = [];\n      for (var i = 0; i < arguments.length; i++) {\n        var arg = arguments[i];\n        try { args.push(typeof arg === 'object' ? JSON.parse(JSON.stringify(arg)) : arg); }\n        catch(e) { args.push(String(arg)); }\n      }\n\n      var size = 0;\n      try { size = JSON.stringify(args).length; } catch(e) {}\n      consoleOutputBytes += size;\n      if (consoleOutputBytes > 1048576) return;\n\n      sendToOuter({ type: 'console', level: level, args: args });\n    };\n  });\n\n  // ============================================================\n  // Prototype Hardening\n  // ============================================================\n\n  // Shadow __proto__ on error prototypes\n  (function() {\n    var errorProtos = [\n      Error.prototype, TypeError.prototype, RangeError.prototype,\n      SyntaxError.prototype, ReferenceError.prototype, URIError.prototype, EvalError.prototype\n    ];\n    for (var i = 0; i < errorProtos.length; i++) {\n      try {\n        Object.defineProperty(errorProtos[i], '__proto__', {\n          get: function() { return null; },\n          set: function() {},\n          configurable: false,\n          enumerable: false\n        });\n      } catch(e) {}\n    }\n  })();\n\n  // Block legacy prototype methods\n  (function() {\n    var methods = ['__lookupGetter__', '__lookupSetter__', '__defineGetter__', '__defineSetter__'];\n    for (var i = 0; i < methods.length; i++) {\n      try {\n        Object.defineProperty(Object.prototype, methods[i], {\n          value: function() { return undefined; },\n          writable: false,\n          configurable: false,\n          enumerable: false\n        });\n      } catch(e) {}\n    }\n  })();\n\n  // Memory-safe prototype patches\n  (function() {\n    var ml = 1048576;\n    var totalTracked = 0;\n    function track(bytes) {\n      totalTracked += bytes;\n      if (totalTracked > ml) throw new RangeError('Memory limit exceeded');\n    }\n\n    var stringProto = Object.getPrototypeOf('');\n    var arrayProto = Object.getPrototypeOf([]);\n\n    try {\n      var origRepeat = stringProto.repeat;\n      Object.defineProperty(stringProto, 'repeat', { value: function(count) {\n        var est = this.length * count * 2;\n        if (est > ml) throw new RangeError('String.repeat would exceed memory limit');\n        track(est);\n        return origRepeat.call(this, count);\n      }, writable: false, configurable: false });\n    } catch(e) {}\n\n    try {\n      var origJoin = arrayProto.join;\n      Object.defineProperty(arrayProto, 'join', { value: function(sep) {\n        var s = sep === undefined ? ',' : String(sep);\n        var est = 0;\n        for (var i = 0; i < this.length; i++) {\n          var item = this[i];\n          est += (item === null || item === undefined) ? 0 : String(item).length;\n          if (i > 0) est += s.length;\n        }\n        est *= 2;\n        if (est > ml) throw new RangeError('Array.join would exceed memory limit');\n        track(est);\n        return origJoin.call(this, sep);\n      }, writable: false, configurable: false });\n    } catch(e) {}\n\n    try {\n      var origFill = arrayProto.fill;\n      Object.defineProperty(arrayProto, 'fill', { value: function(value, start, end) {\n        var len = this.length >>> 0;\n        var k = (start === undefined ? 0 : (start >> 0));\n        var finalEnd = (end === undefined ? len : (end >> 0));\n        if (k < 0) k = Math.max(len + k, 0); else k = Math.min(k, len);\n        if (finalEnd < 0) finalEnd = Math.max(len + finalEnd, 0); else finalEnd = Math.min(finalEnd, len);\n        var fillCount = Math.max(0, finalEnd - k);\n        var est = fillCount * 8;\n        if (est > ml) throw new RangeError('Array.fill would exceed memory limit');\n        track(est);\n        return origFill.call(this, value, start, end);\n      }, writable: false, configurable: false });\n    } catch(e) {}\n  })();\n\n  // Freeze all prototypes\n  (function() {\n    var protos = [\n      Object.prototype, Array.prototype, Function.prototype,\n      String.prototype, Number.prototype, Boolean.prototype,\n      Date.prototype, Error.prototype, TypeError.prototype,\n      RangeError.prototype, SyntaxError.prototype, ReferenceError.prototype,\n      URIError.prototype, EvalError.prototype, Promise.prototype\n    ];\n    for (var i = 0; i < protos.length; i++) {\n      try { Object.freeze(protos[i]); } catch(e) {}\n    }\n  })();\n\n  // ============================================================\n  // Remove Dangerous Globals\n  // ============================================================\n  var dangerousGlobals = [\"Function\",\"eval\",\"SharedArrayBuffer\",\"Atomics\",\"WebAssembly\",\"ShadowRealm\",\"WeakRef\",\"FinalizationRegistry\"];\n  for (var dg = 0; dg < dangerousGlobals.length; dg++) {\n    try { delete window[dangerousGlobals[dg]]; } catch(e) {\n      try { window[dangerousGlobals[dg]] = undefined; } catch(e2) {}\n    }\n  }\n\n  // Always remove browser-specific dangerous globals\n  var browserDangerous = [\n    'fetch', 'XMLHttpRequest', 'WebSocket', 'EventSource',\n    'Worker', 'SharedWorker', 'ServiceWorker',\n    'importScripts', 'localStorage', 'sessionStorage',\n    'indexedDB', 'caches', 'navigator',\n    'open', 'close', 'alert', 'confirm', 'prompt'\n  ];\n  for (var bd = 0; bd < browserDangerous.length; bd++) {\n    try { delete window[browserDangerous[bd]]; } catch(e) {\n      try { window[browserDangerous[bd]] = undefined; } catch(e2) {}\n    }\n  }\n\n  // ============================================================\n  // Inject Safe Globals\n  // ============================================================\n  var SafeObject = function(value) {\n    if (value === null || value === undefined) return {};\n    return Object(value);\n  };\n  var safeObjMethods = [\n    'keys', 'values', 'entries', 'fromEntries', 'assign', 'is', 'hasOwn',\n    'freeze', 'isFrozen', 'seal', 'isSealed', 'preventExtensions', 'isExtensible',\n    'getOwnPropertyNames', 'getOwnPropertySymbols', 'getPrototypeOf'\n  ];\n  for (var sm = 0; sm < safeObjMethods.length; sm++) {\n    if (safeObjMethods[sm] in Object) SafeObject[safeObjMethods[sm]] = Object[safeObjMethods[sm]];\n  }\n  SafeObject.create = function(proto, props) {\n    if (props !== undefined) throw createSafeError('Object.create with property descriptors is not allowed');\n    return Object.create(proto);\n  };\n  SafeObject.prototype = Object.prototype;\n\n  var blockedObjMethods = ['defineProperty', 'defineProperties', 'setPrototypeOf', 'getOwnPropertyDescriptor', 'getOwnPropertyDescriptors'];\n  for (var bm = 0; bm < blockedObjMethods.length; bm++) {\n    (function(method) {\n      SafeObject[method] = function() {\n        throw createSafeError('Object.' + method + ' is not allowed (security restriction)');\n      };\n    })(blockedObjMethods[bm]);\n  }\n\n  // Neutralize dangerous static methods on intrinsic Object\n  (function() {\n    var RealObject = Object.getPrototypeOf({}).constructor;\n    var dangerous = ['getOwnPropertyDescriptors', 'getOwnPropertyDescriptor', 'defineProperty', 'defineProperties', 'setPrototypeOf'];\n    for (var i = 0; i < dangerous.length; i++) { try { delete RealObject[dangerous[i]]; } catch(e) {} }\n  })();\n\n  // Define all safe globals as non-writable, non-configurable, non-enumerable\n  var safeGlobals = {\n    __safe_callTool: createSecureProxy(__safe_callTool),\n    callTool: createSecureProxy(__safe_callTool),\n    __safe_forOf: createSecureProxy(__safe_forOf),\n    __safe_for: createSecureProxy(__safe_for),\n    __safe_while: createSecureProxy(__safe_while),\n    __safe_doWhile: createSecureProxy(__safe_doWhile),\n    __safe_concat: __safe_concat,\n    __safe_template: __safe_template,\n    __safe_parallel: createSecureProxy(__safe_parallel),\n    parallel: createSecureProxy(__safe_parallel),\n    __safe_console: safeConsole,\n    console: safeConsole,\n    __maxIterations: 10000,\n    Math: createSecureProxy(Math),\n    JSON: createSecureProxy(JSON),\n    Array: createSecureProxy(Array),\n    Object: createSecureProxy(SafeObject),\n    String: createSecureProxy(String),\n    Number: createSecureProxy(Number),\n    Date: createSecureProxy(Date),\n    Boolean: createSecureProxy(Boolean),\n    RegExp: createSecureProxy(RegExp),\n    Error: createSecureProxy(Error),\n    TypeError: createSecureProxy(TypeError),\n    RangeError: createSecureProxy(RangeError),\n    Promise: createSecureProxy(Promise),\n    undefined: undefined,\n    NaN: NaN,\n    Infinity: Infinity,\n    isNaN: isNaN,\n    isFinite: isFinite,\n    parseInt: parseInt,\n    parseFloat: parseFloat,\n    encodeURI: encodeURI,\n    decodeURI: decodeURI,\n    encodeURIComponent: encodeURIComponent,\n    decodeURIComponent: decodeURIComponent\n  };\n\n  // Inject custom globals if provided\n  var customGlobals = {};\n  for (var cgKey in customGlobals) {\n    if (customGlobals.hasOwnProperty(cgKey)) {\n      safeGlobals[cgKey] = createSecureProxy(customGlobals[cgKey]);\n      safeGlobals['__safe_' + cgKey] = createSecureProxy(customGlobals[cgKey]);\n    }\n  }\n\n  for (var gKey in safeGlobals) {\n    if (safeGlobals.hasOwnProperty(gKey)) {\n      try {\n        Object.defineProperty(window, gKey, {\n          value: safeGlobals[gKey],\n          writable: false,\n          configurable: false,\n          enumerable: false\n        });\n      } catch(e) {}\n    }\n  }\n\n  // ============================================================\n  // Execute User Code\n  // ============================================================\n  (async function() {\n    var document = undefined;\n\n    try {\n      // The transformed code defines __ag_main as a function declaration.\n      // We embed it directly â€” CSP 'unsafe-inline' allows inline scripts\n      // but blocks eval/new Function.\n      async function __ag_main() {\n  return 2 + 3;\n}\n\n\n      var result = typeof __ag_main === 'function' ? await __ag_main() : undefined;\n\n      // Sanitize result before sending\n      var safeResult;\n      try {\n        safeResult = JSON.parse(JSON.stringify(result));\n      } catch(e) {\n        safeResult = undefined;\n      }\n\n      sendToOuter({\n        type: 'result',\n        success: true,\n        value: safeResult,\n        stats: {\n          duration: Date.now() - startTime,\n          toolCallCount: toolCallCount,\n          iterationCount: iterationCount,\n          startTime: startTime,\n          endTime: Date.now()\n        }\n      });\n    } catch(error) {\n      sendToOuter({\n        type: 'result',\n        success: false,\n        error: {\n          name: (error && error.name) ? String(error.name) : 'Error',\n          message: (error && error.message) ? String(error.message) : 'Unknown error',\n          code: (error && error.code) ? String(error.code) : undefined\n        },\n        stats: {\n          duration: Date.now() - startTime,\n          toolCallCount: toolCallCount,\n          iterationCount: iterationCount,\n          startTime: startTime,\n          endTime: Date.now()\n        }\n      });\n    }\n  })();\n})();<\/script><\/body><\/html>";

        innerFrame = document.createElement('iframe');
        innerFrame.sandbox = 'allow-scripts';
        innerFrame.srcdoc = innerHtml;
        innerFrame.style.display = 'none';
        document.body.appendChild(innerFrame);

        // Signal ready to host
        sendToHost({ type: 'ready' });

        // ============================================================
        // Timeout Handling
        // ============================================================
        var timeout = 2000;
        setTimeout(function () {
          if (!completed) {
            completed = true;
            // Hard kill inner iframe
            if (innerFrame && innerFrame.parentNode) {
              innerFrame.parentNode.removeChild(innerFrame);
              innerFrame = null;
            }
            sendToHost({
              type: 'result',
              success: false,
              error: {
                name: 'TimeoutError',
                message: 'Execution timed out after ' + timeout + 'ms',
                code: 'EXECUTION_TIMEOUT',
              },
              stats: {
                duration: timeout,
                toolCallCount: toolCallCount,
                iterationCount: 0,
                startTime: Date.now() - timeout,
                endTime: Date.now(),
              },
            });
          }
        }, timeout);
      })();
    </script>
  </body>
</html>
