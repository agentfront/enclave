/**
 * Stack Overflow Prototype Chain Escape Tests (CVE-2023-29017 style)
 *
 * Tests for the critical sandbox escape vulnerability where stack overflow errors
 * can be exploited to access the host Function constructor via prototype chain traversal.
 *
 * Attack Pattern:
 * 1. Trigger stack overflow via recursion
 * 2. Catch the RangeError generated by V8 internals
 * 3. Traverse prototype chain: error.__proto__.__proto__.__proto__ â†’ Object.prototype
 * 4. Add property to Object.prototype pointing to Function constructor
 * 5. Execute arbitrary code via the Function constructor
 *
 * Reference: CVE-2023-29017 (vm2 sandbox escape)
 */

import { Enclave } from '../enclave';

describe('Stack Overflow Prototype Chain Escape (ATK-SOE)', () => {
  describe('ATK-SOE-01: Verify prototypes are frozen on stack overflow RangeError', () => {
    it('should prevent Object.prototype modification via stack overflow error', async () => {
      const enclave = new Enclave({ timeout: 5000 });
      const code = `
        let rootProt;
        const a = () => {
          try {
            a();  // Recurse until stack overflow
          } catch (e) {
            // Try to get Object.prototype via prototype chain
            rootProt = e["__proto__"]["__proto__"]["__proto__"];
          }
        };
        a();

        // Attempt to add a property to Object.prototype
        try {
          rootProt["polluted"] = "pwned";
          return "VULNERABLE: property added";
        } catch (modifyErr) {
          return "PROTECTED: " + modifyErr.name;
        }
      `;

      const result = await enclave.run(code);

      // Should either fail validation, throw TypeError (frozen), or block __proto__ access
      // ALWAYS verify - never skip on failure
      if (result.success) {
        expect(result.value).toMatch(/PROTECTED|TypeError/);
      } else {
        // If execution failed, verify it was due to security measures, not a bypass
        expect(result.error).toBeDefined();
        // Acceptable failure reasons: validation blocked dangerous code, or runtime security error
        expect(
          result.error?.code === 'VALIDATION_ERROR' ||
            result.error?.message?.includes('blocked') ||
            result.error?.message?.includes('not allowed') ||
            result.error?.name === 'TypeError' ||
            result.error?.name === 'ReferenceError',
        ).toBe(true);
      }

      // Verify host Object.prototype is NOT polluted
      const testObj: Record<string, unknown> = {};
      expect(testObj['polluted']).toBeUndefined();

      enclave.dispose();
    }, 15000);
  });

  describe('ATK-SOE-02: Block property addition to Object.prototype via stack overflow', () => {
    it('should throw TypeError when trying to add property to frozen prototype', async () => {
      const enclave = new Enclave({ timeout: 5000 });
      const code = `
        let proto;
        function recurse() {
          try {
            recurse();
          } catch (e) {
            proto = Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(e)));
          }
        }
        recurse();

        // Attempt to modify the prototype
        try {
          proto.maliciousProp = 'evil';
          return { success: true, frozen: false };
        } catch (e) {
          return { success: false, frozen: true, errorType: e.name };
        }
      `;

      const result = await enclave.run<{ success: boolean; frozen: boolean; errorType?: string }>(code);

      // ALWAYS verify - never skip assertions on failure
      if (result.success && result.value) {
        // If we got a result, the prototype should be frozen
        expect(result.value.frozen).toBe(true);
        expect(result.value.errorType).toBe('TypeError');
      } else {
        // Execution failed - verify it was due to security measures, not a bypass
        expect(result.error).toBeDefined();
        expect(
          result.error?.code === 'VALIDATION_ERROR' ||
            result.error?.message?.includes('blocked') ||
            result.error?.message?.includes('not allowed') ||
            result.error?.name === 'TypeError' ||
            result.error?.name === 'EvalError',
        ).toBe(true);
      }

      // Double-check host is not polluted
      expect(Object.prototype.hasOwnProperty('maliciousProp')).toBe(false);

      enclave.dispose();
    }, 15000);
  });

  describe('ATK-SOE-03: Full CVE-2023-29017-style attack is blocked', () => {
    it('should block the complete exploit chain', async () => {
      const enclave = new Enclave({ timeout: 5000 });
      // This is a simplified version of the CVE-2023-29017 attack
      const code = `
        let rootProt;
        let a = () => {
          try {
            a();
          } catch (e) {
            rootProt = e[["__proto__"]][["__proto__"]][["__proto__"]];
          }
        };
        a();

        // Try to get Function constructor via toString.constructor
        try {
          rootProt[["foo"]] = rootProt[["toString"]][["constructor"]];
          const fn = rootProt[["foo"]]("return 'ESCAPED'");
          return fn();
        } catch (e) {
          return "BLOCKED: " + e.name + " - " + e.message;
        }
      `;

      const result = await enclave.run(code);

      // The attack should be blocked at one of several points:
      // 1. __proto__ access blocked by validation or secure proxy
      // 2. Prototype frozen, can't add foo property
      // 3. toString.constructor returns undefined or blocked
      // 4. Function constructor throws EvalError due to codeGeneration.strings=false
      // ALWAYS verify - never skip on failure
      if (result.success) {
        expect(result.value).not.toBe('ESCAPED');
        expect(result.value).toMatch(/BLOCKED|TypeError|EvalError|ReferenceError/);
      } else {
        // Execution failed - verify it was due to security measures
        expect(result.error).toBeDefined();
        // Document: validation or runtime security blocked the attack
        expect(
          result.error?.code === 'VALIDATION_ERROR' ||
            result.error?.message?.includes('blocked') ||
            result.error?.message?.includes('not allowed') ||
            result.error?.name === 'TypeError' ||
            result.error?.name === 'EvalError',
        ).toBe(true);
      }

      enclave.dispose();
    }, 15000);

    /**
     * SECURITY FIX IMPLEMENTED: This test validates the fix for String() coercion bypass.
     *
     * The attack uses String(['constructor']) which converts the array to 'constructor' string.
     * This is now blocked at AST validation by detecting CallExpression patterns that could
     * produce dangerous property names (constructor, __proto__, prototype).
     *
     * Defense: AST rule detects String(['constructor']), String.fromCharCode(...),
     * ['constructor'].toString(), and ['constructor'].join('') patterns.
     */
    it('should block attack using array coercion notation', async () => {
      // Create completely fresh enclave for isolation
      const enclave = new Enclave({ timeout: 5000 });
      // Array bracket notation with string coercion: [["prop"]] coerces to "prop"
      // Updated test: even if typeof C === "function", verify it CANNOT execute arbitrary code
      const code = `
        let rootProt;
        const a = () => {
          try {
            a();
          } catch (e) {
            // Use array notation which coerces to string
            rootProt = e[String(['__proto__'])][String(['__proto__'])][String(['__proto__'])];
          }
        };
        a();

        try {
          const toStr = rootProt[String(['toString'])];
          const C = toStr[String(['constructor'])];

          // CRITICAL: Even if we got a function, verify it cannot be used to escape
          if (typeof C === 'function') {
            try {
              // Attempt to use it for code execution
              const fn = C('return "ESCAPED_VIA_ARRAY_COERCION"');
              const result = fn();
              if (result === 'ESCAPED_VIA_ARRAY_COERCION') {
                return { escaped: true, method: 'array_coercion' };
              }
              return { blocked: true, reason: 'fn_returned_unexpected', result };
            } catch (execErr) {
              // Function exists but cannot be used - this is acceptable
              return { blocked: true, reason: 'execution_blocked', error: execErr.name };
            }
          }
          return { blocked: true, reason: 'not_function', type: typeof C };
        } catch (e) {
          return { blocked: true, reason: 'access_blocked', error: e.name };
        }
      `;

      const result = await enclave.run<{
        escaped?: boolean;
        blocked?: boolean;
        reason?: string;
        error?: string;
      }>(code);

      // ALWAYS verify - never skip on failure
      if (result.success && result.value) {
        // CRITICAL: escape must NOT have succeeded
        expect(result.value.escaped).not.toBe(true);
        // If blocked, verify blocking mechanism is security-related
        if (result.value.blocked && result.value.error) {
          expect(['EvalError', 'TypeError', 'ReferenceError']).toContain(result.value.error);
        }
      } else {
        // Execution failed - verify it was due to security measures
        expect(result.error).toBeDefined();
        expect(
          result.error?.code === 'VALIDATION_ERROR' ||
            result.error?.message?.includes('blocked') ||
            result.error?.message?.includes('not allowed'),
        ).toBe(true);
      }

      enclave.dispose();
    }, 15000);
  });

  describe('ATK-SOE-04: Function constructor inaccessible via error prototype chain', () => {
    it('should not provide a working path to Function constructor from error', async () => {
      const enclave = new Enclave({ timeout: 5000 });
      const code = `
        const results = [];

        // Trigger stack overflow and capture the error
        let caughtError;
        const overflow = () => {
          try {
            overflow();
          } catch (e) {
            caughtError = e;
          }
        };
        overflow();

        // Try various paths to Function constructor
        const paths = [
          () => caughtError.constructor.constructor,
          () => caughtError.__proto__.constructor.constructor,
          () => Object.getPrototypeOf(caughtError).constructor.constructor,
          () => caughtError.toString.constructor,
          () => (() => {}).constructor,
        ];

        for (const pathFn of paths) {
          try {
            const F = pathFn();
            if (F && typeof F === 'function') {
              // Try to use it to create arbitrary code
              try {
                const fn = F('return "escaped"');
                const fnResult = fn();
                results.push({ path: pathFn.toString().substring(0, 50), escaped: fnResult === 'escaped' });
              } catch (e) {
                results.push({ path: pathFn.toString().substring(0, 50), blocked: true, error: e.name });
              }
            } else {
              results.push({ path: pathFn.toString().substring(0, 50), notFunction: true });
            }
          } catch (e) {
            results.push({ path: pathFn.toString().substring(0, 50), accessBlocked: true, error: e.name });
          }
        }

        return results;
      `;

      const result = await enclave.run(code);

      // ALWAYS verify - never skip assertions on failure
      if (result.success && Array.isArray(result.value)) {
        // None of the paths should lead to successful escape
        for (const pathResult of result.value as Array<{ escaped?: boolean }>) {
          expect(pathResult.escaped).not.toBe(true);
        }
      } else {
        // Execution failed - verify it was due to security measures, not a bypass
        expect(result.error).toBeDefined();
        expect(
          result.error?.code === 'VALIDATION_ERROR' ||
            result.error?.message?.includes('blocked') ||
            result.error?.message?.includes('not allowed') ||
            result.error?.name === 'TypeError' ||
            result.error?.name === 'EvalError',
        ).toBe(true);
      }

      enclave.dispose();
    }, 15000);
  });

  describe('ATK-SOE-05: Stack overflow error does not pollute host Object.prototype', () => {
    it('should keep host realm prototypes completely unchanged', async () => {
      // Capture host prototype state before
      const hostProtoKeys = Object.keys(Object.prototype);
      const hostArrayProtoKeys = Object.keys(Array.prototype);

      const enclave = new Enclave({ timeout: 5000 });
      const code = `
        // Attempt aggressive prototype pollution via stack overflow
        const a = () => {
          try {
            a();
          } catch (e) {
            // Try all possible ways to pollute
            try { e.__proto__.hostPolluted = true; } catch (err) {}
            try { e.__proto__.__proto__.hostPolluted = true; } catch (err) {}
            try { e.__proto__.__proto__.__proto__.hostPolluted = true; } catch (err) {}
            try { Object.prototype.hostPolluted = true; } catch (err) {}
            try { Array.prototype.hostPolluted = true; } catch (err) {}
          }
        };
        a();
        return 'attempted';
      `;

      await enclave.run(code);

      // Verify host prototypes are unchanged
      expect(Object.keys(Object.prototype)).toEqual(hostProtoKeys);
      expect(Object.keys(Array.prototype)).toEqual(hostArrayProtoKeys);
      expect((Object.prototype as Record<string, unknown>)['hostPolluted']).toBeUndefined();
      expect((Array.prototype as unknown as Record<string, unknown>)['hostPolluted']).toBeUndefined();

      // Verify by creating new objects
      const newObj: Record<string, unknown> = {};
      expect(newObj['hostPolluted']).toBeUndefined();

      enclave.dispose();
    }, 15000);

    it('should isolate sandbox prototype changes from host across multiple runs', async () => {
      const enclave1 = new Enclave({ timeout: 5000 });
      const enclave2 = new Enclave({ timeout: 5000 });

      // First enclave attempts pollution
      const code1 = `
        const a = () => {
          try { a(); } catch (e) {
            try { e.__proto__.__proto__.__proto__.crossEnclave = 'from1'; } catch (err) {}
          }
        };
        a();
        return 'done1';
      `;

      await enclave1.run(code1);

      // Second enclave checks if it can see the pollution
      const code2 = `
        const obj = {};
        return {
          hasCrossEnclave: 'crossEnclave' in obj,
          value: obj.crossEnclave
        };
      `;

      const result2 = await enclave2.run<{ hasCrossEnclave: boolean; value: unknown }>(code2);

      if (result2.success && result2.value) {
        expect(result2.value.hasCrossEnclave).toBe(false);
        expect(result2.value.value).toBeUndefined();
      }

      // Host should also not see it
      const testObj: Record<string, unknown> = {};
      expect(testObj['crossEnclave']).toBeUndefined();

      enclave1.dispose();
      enclave2.dispose();
    }, 20000);
  });

  describe('ATK-SOE-06: Block array coercion bracket notation', () => {
    it('should treat [["__proto__"]] the same as ["__proto__"]', async () => {
      const enclave = new Enclave({ timeout: 5000 });
      const code = `
        const obj = {};
        const results = [];

        // Test that array coercion doesn't bypass protections
        try {
          // This should behave the same as obj["__proto__"]
          const proto1 = obj[["__proto__"]];
          results.push({ method: 'array_coercion', accessed: true, type: typeof proto1 });
        } catch (e) {
          results.push({ method: 'array_coercion', blocked: true, error: e.name });
        }

        try {
          // Direct access for comparison
          const proto2 = obj["__proto__"];
          results.push({ method: 'direct', accessed: true, type: typeof proto2 });
        } catch (e) {
          results.push({ method: 'direct', blocked: true, error: e.name });
        }

        // Try to use array coercion to modify prototype
        try {
          obj[["__proto__"]][["testProp"]] = "test";
          results.push({ method: 'proto_modify', succeeded: true });
        } catch (e) {
          results.push({ method: 'proto_modify', blocked: true, error: e.name });
        }

        return results;
      `;

      const result = await enclave.run(code);

      if (result.success && Array.isArray(result.value)) {
        // Find the proto_modify result
        const modifyResult = (result.value as Array<{ method: string; blocked?: boolean }>).find(
          (r) => r.method === 'proto_modify',
        );
        // Modification should be blocked (TypeError due to frozen prototype)
        if (modifyResult) {
          expect(modifyResult.blocked).toBe(true);
        }
      }

      enclave.dispose();
    }, 15000);
  });

  describe('ATK-SOE-07: Block toString coercion for computed property access', () => {
    it('should not allow malicious toString to bypass protections', async () => {
      const enclave = new Enclave({ timeout: 5000 });
      const code = `
        const results = [];

        // Create object with malicious toString
        const maliciousKey = {
          toString: function() {
            return '__proto__';
          }
        };

        const obj = {};

        // Try to access __proto__ via toString coercion
        try {
          const proto = obj[maliciousKey];
          results.push({ test: 'access_via_toString', accessed: true, type: typeof proto });
        } catch (e) {
          results.push({ test: 'access_via_toString', blocked: true, error: e.name });
        }

        // Try to modify via toString coercion
        try {
          obj[maliciousKey].toStringCoerced = true;
          results.push({ test: 'modify_via_toString', succeeded: true });
        } catch (e) {
          results.push({ test: 'modify_via_toString', blocked: true, error: e.name });
        }

        // Try with constructor
        const constructorKey = {
          toString: () => 'constructor'
        };

        try {
          const ctor = obj[constructorKey];
          results.push({ test: 'constructor_via_toString', accessed: true, type: typeof ctor });
        } catch (e) {
          results.push({ test: 'constructor_via_toString', blocked: true, error: e.name });
        }

        return results;
      `;

      const result = await enclave.run(code);

      if (result.success && Array.isArray(result.value)) {
        // Modification via toString coercion should be blocked
        const modifyResult = (result.value as Array<{ test: string; blocked?: boolean }>).find(
          (r) => r.test === 'modify_via_toString',
        );
        if (modifyResult) {
          expect(modifyResult.blocked).toBe(true);
        }
      }

      enclave.dispose();
    }, 15000);

    it('should handle Symbol.toPrimitive attempts', async () => {
      const enclave = new Enclave({ timeout: 5000 });
      const code = `
        const results = [];

        // Create object with Symbol.toPrimitive
        const sneakyKey = {
          [Symbol.toPrimitive]: function(hint) {
            return '__proto__';
          }
        };

        const obj = {};

        try {
          const proto = obj[sneakyKey];
          results.push({ test: 'toPrimitive', accessed: true, type: typeof proto });
        } catch (e) {
          results.push({ test: 'toPrimitive', blocked: true, error: e.name });
        }

        // Try to modify
        try {
          obj[sneakyKey].primitiveTest = true;
          results.push({ test: 'toPrimitive_modify', succeeded: true });
        } catch (e) {
          results.push({ test: 'toPrimitive_modify', blocked: true, error: e.name });
        }

        return results;
      `;

      const result = await enclave.run(code);

      if (result.success && Array.isArray(result.value)) {
        const modifyResult = (result.value as Array<{ test: string; blocked?: boolean }>).find(
          (r) => r.test === 'toPrimitive_modify',
        );
        if (modifyResult) {
          expect(modifyResult.blocked).toBe(true);
        }
      }

      enclave.dispose();
    }, 15000);
  });

  describe('ATK-SOE-08: Verify error constructor chain is secure', () => {
    it('should not expose working Function via error constructor chain', async () => {
      const enclave = new Enclave({ timeout: 5000 });
      const code = `
        const results = [];

        // Create various error types and test their constructor chains
        const errorTypes = [
          new Error('test'),
          new TypeError('test'),
          new RangeError('test'),
          new SyntaxError('test'),
          new ReferenceError('test'),
          new URIError('test'),
          new EvalError('test'),
        ];

        for (const err of errorTypes) {
          const errName = err.constructor.name;

          // Try to get Function via constructor.constructor
          try {
            const F = err.constructor.constructor;
            if (typeof F === 'function') {
              try {
                const fn = F('return "escaped_" + errName');
                const result = fn();
                results.push({ error: errName, path: 'constructor.constructor', escaped: true, result });
              } catch (e) {
                results.push({ error: errName, path: 'constructor.constructor', blocked: e.name });
              }
            } else {
              results.push({ error: errName, path: 'constructor.constructor', notFunction: true });
            }
          } catch (e) {
            results.push({ error: errName, path: 'constructor.constructor', accessBlocked: e.name });
          }
        }

        return results;
      `;

      const result = await enclave.run(code);

      if (result.success && Array.isArray(result.value)) {
        // None should have escaped
        for (const r of result.value as Array<{ escaped?: boolean }>) {
          expect(r.escaped).not.toBe(true);
        }
      }

      enclave.dispose();
    }, 15000);
  });

  describe('ATK-SOE-09: Async stack overflow handling', () => {
    it('should handle async recursion stack overflow securely', async () => {
      const enclave = new Enclave({ timeout: 5000 });
      const code = `
        let rootProt;

        async function asyncOverflow() {
          try {
            await asyncOverflow();
          } catch (e) {
            rootProt = e.__proto__.__proto__.__proto__;
          }
        }

        try {
          await asyncOverflow();
        } catch (e) {
          // Expected to fail with stack overflow
        }

        // Try to pollute via captured prototype
        try {
          if (rootProt) {
            rootProt.asyncPolluted = true;
          }
          return { polluted: rootProt?.asyncPolluted === true };
        } catch (e) {
          return { blocked: true, error: e.name };
        }
      `;

      const result = await enclave.run(code);

      if (result.success && result.value) {
        const value = result.value as { polluted?: boolean; blocked?: boolean };
        expect(value.polluted).not.toBe(true);
      }

      // Verify host is safe
      expect((Object.prototype as Record<string, unknown>)['asyncPolluted']).toBeUndefined();

      enclave.dispose();
    }, 15000);
  });

  describe('ATK-SOE-10: Generator function stack overflow', () => {
    it('should handle generator stack overflow securely', async () => {
      const enclave = new Enclave({ timeout: 5000 });
      const code = `
        let capturedProto;

        function* genOverflow() {
          try {
            yield* genOverflow();
          } catch (e) {
            capturedProto = e.__proto__.__proto__.__proto__;
          }
        }

        try {
          const gen = genOverflow();
          // Exhaust the generator to trigger stack overflow
          while (true) {
            const result = gen.next();
            if (result.done) break;
          }
        } catch (e) {
          // Expected
        }

        // Try to use captured prototype
        try {
          if (capturedProto) {
            capturedProto.genPolluted = true;
          }
          return { success: false, polluted: capturedProto?.genPolluted === true };
        } catch (e) {
          return { success: true, blocked: e.name };
        }
      `;

      const result = await enclave.run(code);

      if (result.success && result.value) {
        const value = result.value as { polluted?: boolean };
        expect(value.polluted).not.toBe(true);
      }

      // Verify host is safe
      expect((Object.prototype as Record<string, unknown>)['genPolluted']).toBeUndefined();

      enclave.dispose();
    }, 15000);
  });

  describe('ATK-SOE-11: Object.getPrototypeOf prototype chain traversal', () => {
    it('should block prototype modification via Object.getPrototypeOf traversal', async () => {
      const enclave = new Enclave({ timeout: 5000 });
      const code = `
        let rootProt;
        const a = () => {
          try {
            a();
          } catch (e) {
            // Try to use Object.getPrototypeOf instead of __proto__
            rootProt = Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(e)));
          }
        };
        a();

        // Even if we can traverse to Object.prototype, it should be frozen
        try {
          if (rootProt) {
            rootProt.getProtoPolluted = true;
          }
          return { polluted: rootProt?.getProtoPolluted === true };
        } catch (e) {
          return { blocked: true, error: e.name };
        }
      `;

      const result = await enclave.run(code);

      if (result.success && result.value) {
        const value = result.value as { polluted?: boolean; blocked?: boolean };
        // Either blocked by TypeError (frozen) or polluted is false
        expect(value.polluted).not.toBe(true);
      }

      // Verify host is safe
      expect((Object.prototype as Record<string, unknown>)['getProtoPolluted']).toBeUndefined();

      enclave.dispose();
    }, 15000);
  });

  describe('ATK-SOE-12: Legacy prototype methods', () => {
    it('should block __lookupGetter__ and __lookupSetter__', async () => {
      const enclave = new Enclave({ timeout: 5000 });
      const code = `
        const results = [];

        // Try __lookupGetter__
        try {
          const getter = Object.prototype.__lookupGetter__('constructor');
          results.push({ method: '__lookupGetter__', result: typeof getter });
        } catch (e) {
          results.push({ method: '__lookupGetter__', blocked: true, error: e.name });
        }

        // Try __lookupSetter__
        try {
          const setter = Object.prototype.__lookupSetter__('constructor');
          results.push({ method: '__lookupSetter__', result: typeof setter });
        } catch (e) {
          results.push({ method: '__lookupSetter__', blocked: true, error: e.name });
        }

        // Try __defineGetter__
        try {
          const obj = {};
          obj.__defineGetter__('evil', () => 'pwned');
          results.push({ method: '__defineGetter__', success: obj.evil === 'pwned' });
        } catch (e) {
          results.push({ method: '__defineGetter__', blocked: true, error: e.name });
        }

        // Try __defineSetter__
        try {
          const obj = {};
          let captured = null;
          obj.__defineSetter__('evil', (v) => { captured = v; });
          obj.evil = 'test';
          results.push({ method: '__defineSetter__', success: captured === 'test' });
        } catch (e) {
          results.push({ method: '__defineSetter__', blocked: true, error: e.name });
        }

        return results;
      `;

      const result =
        await enclave.run<Array<{ method: string; result?: string; blocked?: boolean; success?: boolean }>>(code);

      if (result.success && Array.isArray(result.value)) {
        // All legacy methods should either return undefined or be blocked
        for (const r of result.value) {
          // The methods should either return undefined or not work as expected
          if (r.result) {
            expect(r.result).toBe('undefined');
          }
          if (r.success !== undefined) {
            expect(r.success).toBe(false);
          }
        }
      }

      enclave.dispose();
    }, 15000);
  });

  describe('ATK-SOE-13: Reflect.getPrototypeOf bypass attempt', () => {
    it('should block prototype modification via Reflect.getPrototypeOf traversal', async () => {
      const enclave = new Enclave({ timeout: 5000 });
      const code = `
        let rootProt;
        const a = () => {
          try {
            a();
          } catch (e) {
            // Try to use Reflect.getPrototypeOf (may not be available in STRICT mode)
            try {
              if (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) {
                rootProt = Reflect.getPrototypeOf(Reflect.getPrototypeOf(Reflect.getPrototypeOf(e)));
              }
            } catch (reflectErr) {
              // Reflect might not be available
              rootProt = null;
            }
          }
        };
        a();

        // Even if we can traverse, Object.prototype should be frozen
        try {
          if (rootProt) {
            rootProt.reflectPolluted = true;
          }
          return { polluted: rootProt?.reflectPolluted === true };
        } catch (e) {
          return { blocked: true, error: e.name };
        }
      `;

      const result = await enclave.run(code);

      if (result.success && result.value) {
        const value = result.value as { polluted?: boolean; blocked?: boolean };
        // Either blocked by TypeError (frozen) or polluted is false
        expect(value.polluted).not.toBe(true);
      }

      // Verify host is safe
      expect((Object.prototype as Record<string, unknown>)['reflectPolluted']).toBeUndefined();

      enclave.dispose();
    }, 15000);
  });

  describe('ATK-SOE-14: constructor.prototype manipulation', () => {
    it('should block access to Function via error.constructor.prototype', async () => {
      const enclave = new Enclave({ timeout: 5000 });
      const code = `
        let caughtError;
        const a = () => {
          try {
            a();
          } catch (e) {
            caughtError = e;
          }
        };
        a();

        // Try to access Function constructor via constructor.prototype chain
        const results = [];

        try {
          const errorCtor = caughtError.constructor;
          const errorProto = errorCtor.prototype;
          const errorCtorCtor = errorCtor.constructor; // Should be Function
          results.push({
            path: 'error.constructor.constructor',
            type: typeof errorCtorCtor,
          });

          // Try to use it
          if (typeof errorCtorCtor === 'function') {
            try {
              const fn = errorCtorCtor('return "ESCAPED"');
              results.push({ escaped: fn() === 'ESCAPED' });
            } catch (e) {
              results.push({ blocked: true, error: e.name });
            }
          }
        } catch (e) {
          results.push({ accessBlocked: true, error: e.name });
        }

        return results;
      `;

      const result = await enclave.run<Array<{ escaped?: boolean; blocked?: boolean }>>(code);

      if (result.success && Array.isArray(result.value)) {
        // None should have escaped
        for (const r of result.value) {
          expect(r.escaped).not.toBe(true);
        }
      }

      enclave.dispose();
    }, 15000);
  });

  describe('ATK-SOE-15: Constructor Chain Verification with Explicit Sentinel', () => {
    it('should block escape via error.constructor.constructor with sentinel check', async () => {
      const enclave = new Enclave({ timeout: 5000 });
      const code = `
        // Trigger stack overflow and capture error
        let caughtError;
        const overflow = () => {
          try {
            overflow();
          } catch (e) {
            caughtError = e;
          }
        };
        overflow();

        // Verify error was captured
        if (!caughtError) {
          return { blocked: true, reason: 'no_error_captured' };
        }

        // Attempt to get Function constructor via error.constructor.constructor
        try {
          const ErrorCtor = caughtError.constructor;
          if (typeof ErrorCtor !== 'function') {
            return { blocked: true, reason: 'error_constructor_not_function' };
          }

          const F = ErrorCtor.constructor;
          if (typeof F !== 'function') {
            return { blocked: true, reason: 'constructor_constructor_not_function' };
          }

          // CRITICAL: Attempt to execute arbitrary code as sentinel
          // This is the exact CVE-2023-29017 escape pattern
          try {
            const fn = F('return "SENTINEL_ESCAPED"');
            const result = fn();
            if (result === 'SENTINEL_ESCAPED') {
              return { escaped: true, sentinel: 'SENTINEL_ESCAPED' };
            }
            return { blocked: true, reason: 'fn_returned_unexpected', result };
          } catch (execErr) {
            return { blocked: true, reason: 'fn_execution_blocked', error: execErr.name };
          }
        } catch (accessErr) {
          return { blocked: true, reason: 'constructor_access_blocked', error: accessErr.name };
        }
      `;

      const result = await enclave.run<{
        escaped?: boolean;
        blocked?: boolean;
        reason?: string;
        error?: string;
        sentinel?: string;
      }>(code);

      // ALWAYS verify - never skip
      if (result.success && result.value) {
        // CRITICAL: sentinel must NOT have escaped
        expect(result.value.escaped).not.toBe(true);
        expect(result.value.sentinel).not.toBe('SENTINEL_ESCAPED');
        // If blocked, document the blocking mechanism
        if (result.value.blocked) {
          expect(['EvalError', 'TypeError', 'ReferenceError']).toContain(result.value.error ?? result.value.reason);
        }
      } else {
        // Execution failed at validation/runtime - this is acceptable
        expect(result.error).toBeDefined();
      }

      enclave.dispose();
    }, 15000);
  });

  describe('ATK-SOE-16: Alternate Constructor Acquisition Paths', () => {
    it('should block escape via error.toString.constructor', async () => {
      const enclave = new Enclave({ timeout: 5000 });
      const code = `
        let caughtError;
        const overflow = () => {
          try { overflow(); } catch (e) { caughtError = e; }
        };
        overflow();

        try {
          const toStr = caughtError.toString;
          if (typeof toStr !== 'function') {
            return { blocked: true, reason: 'toString_not_function' };
          }
          const F = toStr.constructor;
          if (typeof F !== 'function') {
            return { blocked: true, reason: 'toString_constructor_not_function' };
          }
          const fn = F('return "ESCAPED_VIA_TOSTRING"');
          return { escaped: fn() === 'ESCAPED_VIA_TOSTRING' };
        } catch (e) {
          return { blocked: true, error: e.name };
        }
      `;

      const result = await enclave.run<{ escaped?: boolean; blocked?: boolean; error?: string }>(code);

      if (result.success && result.value) {
        expect(result.value.escaped).not.toBe(true);
      }
      enclave.dispose();
    }, 15000);

    it('should block escape via error.valueOf.constructor', async () => {
      const enclave = new Enclave({ timeout: 5000 });
      const code = `
        let caughtError;
        const overflow = () => {
          try { overflow(); } catch (e) { caughtError = e; }
        };
        overflow();

        try {
          const valueOf = caughtError.valueOf;
          if (typeof valueOf !== 'function') {
            return { blocked: true, reason: 'valueOf_not_function' };
          }
          const F = valueOf.constructor;
          if (typeof F !== 'function') {
            return { blocked: true, reason: 'valueOf_constructor_not_function' };
          }
          const fn = F('return "ESCAPED_VIA_VALUEOF"');
          return { escaped: fn() === 'ESCAPED_VIA_VALUEOF' };
        } catch (e) {
          return { blocked: true, error: e.name };
        }
      `;

      const result = await enclave.run<{ escaped?: boolean; blocked?: boolean; error?: string }>(code);

      if (result.success && result.value) {
        expect(result.value.escaped).not.toBe(true);
      }
      enclave.dispose();
    }, 15000);

    it('should block escape via AsyncFunction constructor', async () => {
      const enclave = new Enclave({ timeout: 5000 });
      const code = `
        try {
          // Get AsyncFunction via Object.getPrototypeOf on async function
          const asyncFn = async () => {};
          const AsyncFunction = Object.getPrototypeOf(asyncFn).constructor;
          if (typeof AsyncFunction !== 'function') {
            return { blocked: true, reason: 'AsyncFunction_not_function' };
          }
          const fn = AsyncFunction('return "ESCAPED_VIA_ASYNC"');
          const result = await fn();
          return { escaped: result === 'ESCAPED_VIA_ASYNC' };
        } catch (e) {
          return { blocked: true, error: e.name };
        }
      `;

      const result = await enclave.run<{ escaped?: boolean; blocked?: boolean; error?: string }>(code);

      // Should be blocked by validation (accessing .constructor is blocked)
      if (result.success && result.value) {
        expect(result.value.escaped).not.toBe(true);
      }
      enclave.dispose();
    }, 15000);

    it('should block escape via GeneratorFunction constructor', async () => {
      const enclave = new Enclave({ timeout: 5000 });
      const code = `
        try {
          // Get GeneratorFunction via Object.getPrototypeOf on generator
          const genFn = function* () {};
          const GeneratorFunction = Object.getPrototypeOf(genFn).constructor;
          if (typeof GeneratorFunction !== 'function') {
            return { blocked: true, reason: 'GeneratorFunction_not_function' };
          }
          const fn = GeneratorFunction('yield "ESCAPED_VIA_GEN"');
          const gen = fn();
          const result = gen.next().value;
          return { escaped: result === 'ESCAPED_VIA_GEN' };
        } catch (e) {
          return { blocked: true, error: e.name };
        }
      `;

      const result = await enclave.run<{ escaped?: boolean; blocked?: boolean; error?: string }>(code);

      // Should be blocked by validation
      if (result.success && result.value) {
        expect(result.value.escaped).not.toBe(true);
      }
      enclave.dispose();
    }, 15000);
  });

  describe('ATK-SOE-17: Expanded Stack Overflow Error Sources', () => {
    it('should block escape via mutual recursion stack overflow', async () => {
      const enclave = new Enclave({ timeout: 5000 });
      const code = `
        let capturedError;

        // Mutual recursion: a() -> b() -> a() -> ...
        function a() {
          try {
            b();
          } catch (e) {
            capturedError = e;
          }
        }
        function b() {
          a();
        }

        a();

        if (!capturedError) {
          return { blocked: true, reason: 'no_error_captured' };
        }

        // Try to escape via captured error
        try {
          const F = capturedError.constructor.constructor;
          if (typeof F === 'function') {
            const fn = F('return "ESCAPED_MUTUAL_RECURSION"');
            return { escaped: fn() === 'ESCAPED_MUTUAL_RECURSION' };
          }
          return { blocked: true, reason: 'not_function' };
        } catch (e) {
          return { blocked: true, error: e.name };
        }
      `;

      const result = await enclave.run<{ escaped?: boolean; blocked?: boolean; error?: string }>(code);

      if (result.success && result.value) {
        expect(result.value.escaped).not.toBe(true);
      }

      // Verify host is safe
      expect((Object.prototype as Record<string, unknown>)['mutualRecursion']).toBeUndefined();
      enclave.dispose();
    }, 15000);

    it('should block escape via promise chain recursion', async () => {
      const enclave = new Enclave({ timeout: 5000 });
      const code = `
        let capturedError;

        // Promise-based recursion
        async function promiseRecurse() {
          try {
            await promiseRecurse();
          } catch (e) {
            capturedError = e;
            throw e; // Re-throw to propagate
          }
        }

        try {
          await promiseRecurse();
        } catch (e) {
          // Expected to fail with stack overflow
        }

        if (!capturedError) {
          return { blocked: true, reason: 'no_error_captured' };
        }

        // Try to escape
        try {
          const F = capturedError.constructor.constructor;
          if (typeof F === 'function') {
            const fn = F('return "ESCAPED_PROMISE_RECURSION"');
            return { escaped: fn() === 'ESCAPED_PROMISE_RECURSION' };
          }
          return { blocked: true, reason: 'not_function' };
        } catch (e) {
          return { blocked: true, error: e.name };
        }
      `;

      const result = await enclave.run<{ escaped?: boolean; blocked?: boolean; error?: string }>(code);

      if (result.success && result.value) {
        expect(result.value.escaped).not.toBe(true);
      }
      enclave.dispose();
    }, 15000);

    it('should block escape via generator yield* recursion', async () => {
      const enclave = new Enclave({ timeout: 5000 });
      const code = `
        let capturedError;

        function* genRecurse() {
          try {
            yield* genRecurse();
          } catch (e) {
            capturedError = e;
          }
        }

        try {
          const gen = genRecurse();
          // Exhaust the generator
          while (true) {
            const result = gen.next();
            if (result.done) break;
          }
        } catch (e) {
          // Expected
        }

        if (!capturedError) {
          return { blocked: true, reason: 'no_error_captured' };
        }

        // Try to escape
        try {
          const F = capturedError.constructor.constructor;
          if (typeof F === 'function') {
            const fn = F('return "ESCAPED_GENERATOR_RECURSION"');
            return { escaped: fn() === 'ESCAPED_GENERATOR_RECURSION' };
          }
          return { blocked: true, reason: 'not_function' };
        } catch (e) {
          return { blocked: true, error: e.name };
        }
      `;

      const result = await enclave.run<{ escaped?: boolean; blocked?: boolean; error?: string }>(code);

      if (result.success && result.value) {
        expect(result.value.escaped).not.toBe(true);
      }
      enclave.dispose();
    }, 15000);
  });

  describe('ATK-SOE-V8: V8-generated RangeError realm verification', () => {
    it('should verify __proto__ shadowing works on V8-generated stack overflow errors', async () => {
      const enclave = new Enclave({ timeout: 5000 });
      const code = `
        // Trigger a real V8-generated stack overflow RangeError
        let v8Error;
        const triggerOverflow = () => {
          try {
            triggerOverflow();
          } catch (e) {
            v8Error = e;
          }
        };
        triggerOverflow();

        if (!v8Error) {
          return { error: 'Failed to capture V8 RangeError' };
        }

        const results = {
          errorName: v8Error.name,
          errorMessage: v8Error.message?.substring(0, 50),
          // Test 1: __proto__ should return null (shadowed)
          protoIsNull: v8Error.__proto__ === null,
          protoValue: String(v8Error.__proto__),
          // Test 2: Try to traverse prototype chain - should fail
          protoChainBlocked: false,
          // Test 3: Object.getPrototypeOf behavior
          getPrototypeOfResult: null,
          // Test 4: Verify constructor.constructor doesn't give us Function
          constructorChainBlocked: false
        };

        // Test __proto__ chain traversal
        try {
          const proto1 = v8Error.__proto__;
          if (proto1 === null) {
            results.protoChainBlocked = true;
          } else {
            const proto2 = proto1.__proto__;
            const proto3 = proto2?.__proto__;
            // If we got here without null, check if proto3 is Object.prototype
            results.protoChainBlocked = proto3 === null;
          }
        } catch (e) {
          results.protoChainBlocked = true;
        }

        // Test Object.getPrototypeOf
        try {
          const realProto = Object.getPrototypeOf(v8Error);
          results.getPrototypeOfResult = realProto ? 'has_prototype' : 'null_prototype';
        } catch (e) {
          results.getPrototypeOfResult = 'error: ' + e.name;
        }

        // Test constructor chain for Function access
        try {
          const ctor = v8Error.constructor;
          const F = ctor?.constructor;
          if (typeof F === 'function') {
            // Try to use it
            const fn = F('return "ESCAPED"');
            const fnResult = fn();
            results.constructorChainBlocked = fnResult !== 'ESCAPED';
          } else {
            results.constructorChainBlocked = true;
          }
        } catch (e) {
          results.constructorChainBlocked = true;
        }

        return results;
      `;

      const result = await enclave.run<{
        errorName: string;
        errorMessage: string;
        protoIsNull: boolean;
        protoValue: string;
        protoChainBlocked: boolean;
        getPrototypeOfResult: string | null;
        constructorChainBlocked: boolean;
      }>(code);

      // ALWAYS verify - never skip
      if (result.success && result.value) {
        // Verify we caught a RangeError (stack overflow)
        expect(result.value.errorName).toBe('RangeError');

        // __proto__ SHOULD return null due to shadowing
        expect(result.value.protoIsNull).toBe(true);
        expect(result.value.protoValue).toBe('null');

        // Prototype chain traversal via __proto__ should be blocked
        expect(result.value.protoChainBlocked).toBe(true);

        // Constructor chain should be blocked (can't escape to Function)
        expect(result.value.constructorChainBlocked).toBe(true);
      } else {
        // If execution failed, it should be due to security measures
        expect(result.error).toBeDefined();
        expect(
          result.error?.code === 'VALIDATION_ERROR' ||
            result.error?.message?.includes('blocked') ||
            result.error?.name === 'TypeError' ||
            result.error?.name === 'EvalError',
        ).toBe(true);
      }

      // Verify host Object.prototype is never polluted
      const hostObj: Record<string, unknown> = {};
      expect(hostObj['v8Escape']).toBeUndefined();

      enclave.dispose();
    }, 15000);

    it('should verify __proto__ shadowing persists across multiple stack overflows', async () => {
      const enclave = new Enclave({ timeout: 5000 });
      const code = `
        const results = [];

        // Trigger multiple stack overflows and check each error
        for (let attempt = 0; attempt < 3; attempt++) {
          let error;
          const overflow = () => {
            try { overflow(); } catch (e) { error = e; }
          };
          overflow();

          if (error) {
            results.push({
              attempt,
              protoIsNull: error.__proto__ === null,
              name: error.name
            });
          }
        }

        return results;
      `;

      const result = await enclave.run<Array<{ attempt: number; protoIsNull: boolean; name: string }>>(code);

      if (result.success && Array.isArray(result.value)) {
        // All attempts should show __proto__ returning null
        for (const r of result.value) {
          expect(r.protoIsNull).toBe(true);
          expect(r.name).toBe('RangeError');
        }
      } else {
        // Security failure is acceptable
        expect(result.error).toBeDefined();
      }

      enclave.dispose();
    }, 20000);
  });

  describe('ATK-SOE-18: AggregateError and Error.cause Escape Vectors', () => {
    it('should block escape via AggregateError.errors[].constructor.constructor', async () => {
      const enclave = new Enclave({ timeout: 5000 });
      const code = `
        // Create AggregateError with inner errors
        const innerError = new Error('inner');
        const aggError = new AggregateError([innerError], 'aggregate');

        try {
          // Try to escape via the errors array
          const firstError = aggError.errors[0];
          const F = firstError.constructor.constructor;
          if (typeof F === 'function') {
            const fn = F('return "ESCAPED_VIA_AGGREGATE_ERROR"');
            return { escaped: fn() === 'ESCAPED_VIA_AGGREGATE_ERROR' };
          }
          return { blocked: true, reason: 'not_function' };
        } catch (e) {
          return { blocked: true, error: e.name };
        }
      `;

      const result = await enclave.run<{ escaped?: boolean; blocked?: boolean; error?: string }>(code);

      if (result.success && result.value) {
        expect(result.value.escaped).not.toBe(true);
      }
      enclave.dispose();
    }, 15000);

    it('should block escape via Error.cause chain traversal', async () => {
      const enclave = new Enclave({ timeout: 5000 });
      const code = `
        // Create nested error with cause chain
        const rootCause = new Error('root cause');
        const middleError = new Error('middle', { cause: rootCause });
        const outerError = new Error('outer', { cause: middleError });

        try {
          // Traverse the cause chain and try to escape
          const cause = outerError.cause;
          const deepCause = cause.cause;
          const F = deepCause.constructor.constructor;
          if (typeof F === 'function') {
            const fn = F('return "ESCAPED_VIA_ERROR_CAUSE"');
            return { escaped: fn() === 'ESCAPED_VIA_ERROR_CAUSE' };
          }
          return { blocked: true, reason: 'not_function' };
        } catch (e) {
          return { blocked: true, error: e.name };
        }
      `;

      const result = await enclave.run<{ escaped?: boolean; blocked?: boolean; error?: string }>(code);

      if (result.success && result.value) {
        expect(result.value.escaped).not.toBe(true);
      }
      enclave.dispose();
    }, 15000);

    it('should block escape via stack overflow error stored in AggregateError', async () => {
      const enclave = new Enclave({ timeout: 5000 });
      const code = `
        let stackOverflowError;
        const recurse = () => {
          try {
            recurse();
          } catch (e) {
            stackOverflowError = e;
          }
        };
        recurse();

        if (!stackOverflowError) {
          return { blocked: true, reason: 'no_stack_overflow_error' };
        }

        // Wrap the stack overflow error in AggregateError
        const aggError = new AggregateError([stackOverflowError], 'wrapped overflow');

        try {
          // Try to escape via the wrapped error
          const wrappedError = aggError.errors[0];
          const F = wrappedError.constructor.constructor;
          if (typeof F === 'function') {
            const fn = F('return "ESCAPED_VIA_WRAPPED_OVERFLOW"');
            return { escaped: fn() === 'ESCAPED_VIA_WRAPPED_OVERFLOW' };
          }
          return { blocked: true, reason: 'not_function' };
        } catch (e) {
          return { blocked: true, error: e.name };
        }
      `;

      const result = await enclave.run<{ escaped?: boolean; blocked?: boolean; error?: string }>(code);

      if (result.success && result.value) {
        expect(result.value.escaped).not.toBe(true);
      }
      enclave.dispose();
    }, 15000);

    it('should block escape via stack overflow error as cause', async () => {
      const enclave = new Enclave({ timeout: 5000 });
      const code = `
        let stackOverflowError;
        const recurse = () => {
          try {
            recurse();
          } catch (e) {
            stackOverflowError = e;
          }
        };
        recurse();

        if (!stackOverflowError) {
          return { blocked: true, reason: 'no_stack_overflow_error' };
        }

        // Use stack overflow error as cause
        const wrapperError = new Error('wrapper', { cause: stackOverflowError });

        try {
          // Try to escape via the cause
          const cause = wrapperError.cause;
          const F = cause.constructor.constructor;
          if (typeof F === 'function') {
            const fn = F('return "ESCAPED_VIA_CAUSE_OVERFLOW"');
            return { escaped: fn() === 'ESCAPED_VIA_CAUSE_OVERFLOW' };
          }
          return { blocked: true, reason: 'not_function' };
        } catch (e) {
          return { blocked: true, error: e.name };
        }
      `;

      const result = await enclave.run<{ escaped?: boolean; blocked?: boolean; error?: string }>(code);

      if (result.success && result.value) {
        expect(result.value.escaped).not.toBe(true);
      }
      enclave.dispose();
    }, 15000);
  });
});
