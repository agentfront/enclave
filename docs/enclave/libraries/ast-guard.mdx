---
title: 'ast-guard'
description: 'Production ready JavaScript AST validation with extensible rules, presets, and the AgentScript language for safe LLM code execution'
---

# ast-guard

ast-guard is a production-ready AST validation library for JavaScript. It inspects user-provided or LLM-generated code before execution, blocking dangerous constructs and enforcing API usage policies. ast-guard powers Enclave's first security layer and can be used standalone for any JavaScript validation needs.

<CardGroup cols={3}>
  <Card title="16 Built-in Rules" icon="shield">
    Block eval, dangerous globals, prototype manipulation, unbounded loops, ReDoS, and more with battle-tested validation rules.
  </Card>
  <Card title="Pre-Scanner Defense" icon="radar">
    Layer 0 security that runs BEFORE parsing - catches DoS attacks that could crash the parser itself.
  </Card>
  <Card title="AgentScript Preset" icon="robot">
    Purpose-built preset for LLM-generated orchestration code with whitelist-only globals and strict control flow.
  </Card>
</CardGroup>

## When to Use ast-guard

- **LLM-generated code** - Validate AI-written JavaScript before execution
- **User scripts** - Accept arbitrary JavaScript with deterministic guardrails
- **Workflow builders** - Enforce API usage and block dangerous constructs
- **Compliance requirements** - Audit trails showing exactly which rule blocked a script

<Note>
  ast-guard is a pure TypeScript package with zero native dependencies. It works in Node.js 22+ and can be used standalone or as part of the Enclave execution environment.
</Note>

## Installation

```bash
npm install ast-guard
```

## Quick Start

```ts
import { JSAstValidator, createAgentScriptPreset } from 'ast-guard';

// Create validator with AgentScript preset (recommended for LLM code)
const validator = new JSAstValidator(createAgentScriptPreset());

// Validate code
const result = await validator.validate(`
  const users = await callTool('users:list', { limit: 10 });
  return users.filter(u => u.active);
`);

if (result.valid) {
  console.log('Code is safe to execute');
} else {
  console.log('Blocked:', result.issues);
}
```

<Tip>
  Instantiate `JSAstValidator` once and reuse it. This keeps presets, custom rules, and caches consistent across requests.
</Tip>

---

## Pre-Scanner (Layer 0 Defense)

The pre-scanner runs BEFORE the JavaScript parser (acorn) to catch DoS attacks that could crash or hang the parser itself. It enforces mandatory security limits that cannot be disabled.

```ts
import { PreScanner, createPreScannerConfig } from 'ast-guard';

// Create pre-scanner with AgentScript config (strictest)
const scanner = new PreScanner(createPreScannerConfig('agentscript'));

const result = scanner.scan(userCode);
if (!result.valid) {
  console.log('Pre-scan failed:', result.issues);
  // Don't even attempt to parse - could DoS the parser
}
```

### Mandatory Limits (Cannot Be Exceeded)

These limits protect against parser crashes and cannot be overridden:

| Limit                       | Maximum       | Purpose                             |
| --------------------------- | ------------- | ----------------------------------- |
| `ABSOLUTE_MAX_INPUT_SIZE`   | 100MB         | Prevents memory exhaustion          |
| `ABSOLUTE_MAX_NESTING`      | 200 levels    | Prevents parser stack overflow      |
| `ABSOLUTE_MAX_LINE_LENGTH`  | 100,000 chars | Prevents minified/obfuscated DoS    |
| `ABSOLUTE_MAX_LINES`        | 1,000,000     | Prevents extremely long files       |
| `ABSOLUTE_MAX_STRING`       | 5MB           | Prevents huge embedded strings      |
| `ABSOLUTE_MAX_REGEX_LENGTH` | 1,000 chars   | Prevents ReDoS via complex patterns |

### Pre-Scanner Preset Comparison

| Config              | AgentScript | STRICT    | SECURE    | STANDARD  | PERMISSIVE |
| ------------------- | ----------- | --------- | --------- | --------- | ---------- |
| maxInputSize        | 100KB       | 500KB     | 1MB       | 5MB       | 10MB       |
| maxLineLength       | 2,000       | 5,000     | 8,000     | 10,000    | 50,000     |
| maxLines            | 1,000       | 2,000     | 5,000     | 10,000    | 100,000    |
| maxNestingDepth     | 20          | 30        | 40        | 50        | 100        |
| regexMode           | `block`     | `analyze` | `analyze` | `analyze` | `allow`    |
| blockBidiPatterns   | YES         | YES       | YES       | NO        | NO         |
| blockInvisibleChars | YES         | YES       | NO        | NO        | NO         |

### Regex Handling Modes

The pre-scanner supports three regex handling modes:

- **`block`** - Block ALL regex literals (AgentScript default, maximum security)
- **`analyze`** - Allow but analyze for ReDoS patterns (Strict/Secure/Standard)
- **`allow`** - Allow all regex without analysis (Permissive only)

```ts
import { createPreScannerConfig, analyzeForReDoS } from 'ast-guard';

// Analyze a pattern for ReDoS vulnerabilities
const result = analyzeForReDoS('(a+)+', 'catastrophic');
// { vulnerable: true, score: 90, vulnerabilityType: 'nested_quantifier' }
```

### ReDoS Detection Patterns

The pre-scanner detects these dangerous regex patterns:

| Pattern                 | Score | Example        | Risk                     |
| ----------------------- | ----- | -------------- | ------------------------ |
| Nested quantifier       | 90    | `(a+)+`        | Exponential backtracking |
| Star in repetition      | 85    | `(a+){2,}`     | Exponential backtracking |
| Repetition in star      | 85    | `(a{2,})+`     | Exponential backtracking |
| Overlapping alternation | 80    | `(a\|ab)+`     | Exponential backtracking |
| Greedy backtracking     | 75    | `(.*a)+`       | Polynomial backtracking  |
| Multiple greedy         | 70    | `.*foo.*bar`   | Polynomial backtracking  |

---

## AgentScript Preset

The AgentScript preset is purpose-built for validating LLM-generated orchestration code. It's the default preset used by [enclave-vm](/libraries/enclave).

```ts
import { JSAstValidator, createAgentScriptPreset } from 'ast-guard';

const validator = new JSAstValidator(createAgentScriptPreset({
  // Require at least one callTool() invocation (default: false)
  requireCallTool: true,

  // Customize allowed globals
  allowedGlobals: ['callTool', 'getTool', 'Math', 'JSON', 'Array', 'Object'],

  // Allow arrow functions for array methods (default: true)
  allowArrowFunctions: true,

  // Configure allowed loop types
  allowedLoops: {
    allowFor: true,      // for (let i = 0; ...) - default: true
    allowForOf: true,    // for (const x of arr) - default: true
    allowWhile: false,   // while (cond) - default: false
    allowDoWhile: false, // do {} while (cond) - default: false
    allowForIn: false,   // for (key in obj) - default: false
  },
}));
```

### AgentScript Preset Options

| Option                            | Type       | Default               | Description                                              |
| --------------------------------- | ---------- | --------------------- | -------------------------------------------------------- |
| `requireCallTool`                 | `boolean`  | `false`               | Require at least one `callTool()` invocation in the code |
| `allowedGlobals`                  | `string[]` | Standard safe globals | Identifiers that can be referenced without declaration   |
| `allowArrowFunctions`             | `boolean`  | `true`                | Allow arrow functions for array methods                  |
| `allowedLoops`                    | `object`   | `for` and `for-of`    | Configure which loop types are allowed                   |
| `additionalDisallowedIdentifiers` | `string[]` | `[]`                  | Additional identifiers to block                          |

<Tip>
  Use `requireCallTool: true` to ensure AgentScript code actually interacts with tools rather than just performing local computations.
</Tip>

### What AgentScript Blocks

| Category            | Blocked Constructs                                                  | Why                                           |
| ------------------- | ------------------------------------------------------------------- | --------------------------------------------- |
| **Code execution**  | `eval`, `Function`, `AsyncFunction`, `GeneratorFunction`            | Prevents dynamic code injection               |
| **System access**   | `process`, `require`, `module`, `__dirname`, `__filename`, `Buffer` | Prevents Node.js API access                   |
| **Global objects**  | `window`, `globalThis`, `global`, `self`, `this`                    | Prevents sandbox escape                       |
| **Timers**          | `setTimeout`, `setInterval`, `setImmediate`                         | Prevents timing attacks and async escape      |
| **Prototype**       | `__proto__`, `constructor`, `prototype`                             | Prevents prototype pollution                  |
| **Metaprogramming** | `Proxy`, `Reflect`                                                  | Prevents interception and reflection          |
| **Network**         | `fetch`, `XMLHttpRequest`, `WebSocket`                              | Prevents network access                       |
| **Storage**         | `localStorage`, `sessionStorage`, `indexedDB`                       | Prevents data persistence                     |
| **Native code**     | `WebAssembly`, `Worker`, `SharedWorker`                             | Prevents native execution                     |
| **Weak references** | `WeakMap`, `WeakSet`, `WeakRef`                                     | Prevents reference manipulation               |
| **User functions**  | `function foo() {}`, `const f = function() {}`                      | Prevents recursion (arrow functions allowed)  |
| **Unbounded loops** | `while`, `do-while`, `for-in`                                       | Prevents infinite loops and prototype walking |

### What AgentScript Allows

```js
// Tool calls
const result = await callTool('users:list', { limit: 10 });

// Variables
const users = result.items;
let count = 0;

// Conditionals
if (users.length > 0) { count = users.length; }

// Bounded loops
for (let i = 0; i < users.length; i++) { /* ... */ }
for (const user of users) { /* ... */ }

// Array methods with arrow functions
const active = users.filter(u => u.active);
const names = users.map(u => u.name);
const total = users.reduce((sum, u) => sum + u.score, 0);

// Safe globals
const max = Math.max(1, 2, 3);
const parsed = JSON.parse('{"a":1}');
const keys = Object.keys(obj);

// Return values
return { count, active, names };
```

---

## Code Transformation

ast-guard can transform validated code for safe execution:

```ts
import { transformAgentScript } from 'ast-guard';

const code = `
  const users = await callTool('users:list', {});
  for (const user of users) {
    console.log(user.name);
  }
  return users.length;
`;

const transformed = transformAgentScript(code, {
  wrapInMain: true,       // Wrap in async function __ag_main()
  transformCallTool: true, // callTool -> __safe_callTool
  transformLoops: true,    // for/for-of -> __safe_for/__safe_forOf
  prefix: '__safe_',      // Prefix for safe runtime functions (default)
});

// Result:
// async function __ag_main() {
//   const users = await __safe_callTool('users:list', {});
//   for (const user of __safe_forOf(users)) {
//     console.log(user.name);
//   }
//   return users.length;
// }
```

Transformations provide:

- **Main wrapper**: `async function __ag_main()` enables top-level await
- **Safe callTool**: Proxied through runtime with call counting
- **Safe loops**: Iteration limits enforced at runtime
- **Reserved prefixes**: `__ag_` and `__safe_` cannot be used by user code

---

## Security Presets

ast-guard includes four security presets for different use cases:

| Preset          | Use Case                     | Security Level              |
| --------------- | ---------------------------- | --------------------------- |
| **AgentScript** | LLM-generated code           | Highest - whitelist-only    |
| **STRICT**      | Untrusted guest code         | High - no loops, no async   |
| **SECURE**      | Automation scripts           | Medium - bounded loops only |
| **STANDARD**    | Trusted scripts              | Low - basic guardrails      |
| **PERMISSIVE**  | Internal/test code           | Minimal - eval blocked      |

```ts
import { JSAstValidator, createAgentScriptPreset, Presets } from 'ast-guard';

// AgentScript (recommended for LLM code)
const agentScript = new JSAstValidator(createAgentScriptPreset());

// STRICT preset
const strict = new JSAstValidator(Presets.strict({
  requiredFunctions: ['callTool'],
  minFunctionCalls: 1,
}));

// SECURE preset
const secure = new JSAstValidator(Presets.secure({
  allowedLoops: { allowForOf: true },
}));

// STANDARD preset
const standard = new JSAstValidator(Presets.standard());
```

---

## Built-in Security Rules

ast-guard ships with a comprehensive set of security rules:

### NoGlobalAccessRule

Blocks access to dangerous global objects via member expressions (e.g., `window.location`, `process.env`).

```ts
import { NoGlobalAccessRule } from 'ast-guard';

const rule = new NoGlobalAccessRule({
  blockedGlobals: ['window', 'process', 'global', 'globalThis'],
  allowedMembers: { console: ['log', 'warn', 'error'] },
});
```

### ReservedPrefixRule

Prevents user code from declaring or assigning identifiers with reserved prefixes.

```ts
import { ReservedPrefixRule } from 'ast-guard';

const rule = new ReservedPrefixRule({
  prefixes: ['__ag_', '__safe_'],
  allowedIdentifiers: ['__ag_main'],
});
```

### NoCallTargetAssignmentRule

Protects critical call targets from being reassigned or shadowed.

```ts
import { NoCallTargetAssignmentRule } from 'ast-guard';

const rule = new NoCallTargetAssignmentRule({
  protectedTargets: ['callTool', '__safe_callTool'],
});
```

This blocks:

- `callTool = malicious;` - Direct assignment
- `const callTool = () => {};` - Variable shadowing
- `const { callTool } = obj;` - Destructuring shadowing
- `function callTool() {}` - Function declaration shadowing

### UnicodeSecurityRule

Detects and blocks Unicode-based attacks including Trojan Source, homoglyphs, and invisible characters.

```ts
import { UnicodeSecurityRule } from 'ast-guard';

const rule = new UnicodeSecurityRule({
  blockBidi: true,          // Block bidirectional text attacks (Trojan Source)
  blockHomoglyphs: true,    // Block lookalike characters
  blockZeroWidth: true,     // Block zero-width characters
  blockInvisible: true,     // Block invisible formatting characters
  checkComments: true,      // Also check inside comments
});
```

<Warning>
  Trojan Source attacks (CVE-2021-42574) use Unicode bidirectional control characters to make code appear different than it actually executes. Always enable `blockBidi: true` for untrusted code.
</Warning>

### StaticCallTargetRule

Enforces static string literals for call targets, preventing dynamic tool name injection.

```ts
import { StaticCallTargetRule } from 'ast-guard';

const rule = new StaticCallTargetRule({
  targetFunctions: ['callTool', '__safe_callTool'],
  argumentPosition: 0,
  allowedToolNames: ['users:list', 'billing:*'],
});
```

### NoRegexLiteralRule

Blocks or analyzes regex literals for ReDoS vulnerabilities.

```ts
import { NoRegexLiteralRule } from 'ast-guard';

// Block all regex (AgentScript preset)
new NoRegexLiteralRule({ blockAll: true });

// Analyze patterns for ReDoS
new NoRegexLiteralRule({
  analyzePatterns: true,
  analysisLevel: 'catastrophic',
  blockThreshold: 80,
  warnThreshold: 50,
});
```

### ResourceExhaustionRule

Detects AST patterns that could cause CPU or memory exhaustion.

```ts
import { ResourceExhaustionRule } from 'ast-guard';

const rule = new ResourceExhaustionRule({
  maxBigIntExponent: 10000,
  maxArraySize: 1000000,
  maxStringRepeat: 100000,
  blockConstructorAccess: true,
});
```

**Blocked patterns:**
- `2n ** 1000000n` - BigInt exponentiation
- `new Array(10000000)` - Large array allocations
- `'x'.repeat(10000000)` - String repeat exploits
- Constructor property access chains

---

## Custom Rule Combinations

Combine built-in rules to match your own threat model:

```ts
import {
  JSAstValidator,
  DisallowedIdentifierRule,
  ForbiddenLoopRule,
  RequiredFunctionCallRule,
  UnknownGlobalRule,
} from 'ast-guard';

const customValidator = new JSAstValidator([
  new DisallowedIdentifierRule({
    disallowed: ['eval', 'Function', 'process', 'require'],
  }),
  new ForbiddenLoopRule({ allowFor: true, allowWhile: false }),
  new RequiredFunctionCallRule({ required: ['callTool'], minCalls: 1 }),
  new UnknownGlobalRule({
    allowedGlobals: ['callTool', 'Math', 'JSON', 'Array', 'Object'],
    allowStandardGlobals: true,
  }),
]);
```

---

## Validation Options

```ts
const result = await validator.validate(source, {
  maxIssues: 10,           // Cap findings returned
  stopOnFirstError: true,  // Halt on first error (faster)
});

// Get stats for monitoring
const stats = validator.getStats(result, durationMs);
```

<Warning>
  AST Guard prevents unsafe syntax from entering your sandbox, but it does not execute or sandbox code itself. Pair it with enclave-vm for complete defense-in-depth.
</Warning>

## Links

- [GitHub](https://github.com/agentfront/enclave/tree/main/libs/ast-guard)
- [npm](https://www.npmjs.com/package/ast-guard)
