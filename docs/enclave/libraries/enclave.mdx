---
title: '@enclave-vm/core'
description: 'Secure JavaScript execution environment with defense-in-depth architecture for running untrusted and LLM-generated code safely'
---

# @enclave-vm/core

Enclave is a secure execution environment for running untrusted JavaScript code. It provides a defense-in-depth security model that combines AST validation (via ast-guard), code transformation, and runtime sandboxing to safely execute model-generated code.

<CardGroup cols={3}>
  <Card title="AST Validation" icon="shield-check">
    Block dangerous constructs before execution using ast-guard's AgentScript preset
  </Card>
  <Card title="Code Transformation" icon="arrows-rotate">
    Automatically transform code for safe execution with proxied functions and loop limits
  </Card>
  <Card title="Runtime Sandboxing" icon="lock">
    Execute in isolated Node.js vm context with controlled globals and resource limits
  </Card>
</CardGroup>

## When to Use Enclave

Enclave is designed for scenarios where you need to execute JavaScript code from untrusted sources:

- **LLM-generated code** - Execute code written by AI models safely
- **User-provided scripts** - Run user scripts in a controlled environment
- **Plugin/extension systems** - Allow third-party code to run securely
- **Workflow automation** - Execute orchestration logic with tool access

## Installation

```bash
npm install @enclave-vm/core
```

## Quick Start

```ts
import { Enclave } from '@enclave-vm/core';

// Create an enclave with a tool handler
const enclave = new Enclave({
  timeout: 5000, // 5 second timeout
  maxToolCalls: 50, // Max 50 tool calls
  maxIterations: 10000, // Max 10K loop iterations
  toolHandler: async (toolName, args) => {
    // Handle tool calls from the script
    console.log(`Tool called: ${toolName}`, args);
    return { result: 'data' };
  },
});

// Execute AgentScript code
const code = `
  const users = await callTool('users:list', { limit: 10 });
  const filtered = users.filter(u => u.active);
  return filtered.length;
`;

const result = await enclave.run(code);

if (result.success) {
  console.log('Result:', result.value);
  console.log('Stats:', result.stats);
} else {
  console.error('Error:', result.error);
}

// Clean up
enclave.dispose();
```

## Security Level Presets

Enclave provides pre-configured security profiles that balance functionality against risk:

```ts
import { Enclave } from '@enclave-vm/core';

// Use STRICT for untrusted AI-generated code
const strictEnclave = new Enclave({ securityLevel: 'STRICT' });

// Use STANDARD for internal tools (default)
const standardEnclave = new Enclave({ securityLevel: 'STANDARD' });

// Override specific values from the preset
const customEnclave = new Enclave({
  securityLevel: 'SECURE',
  timeout: 20000,  // Override SECURE's 15s default
});
```

### Security Level Comparison

| Setting               | STRICT | SECURE | STANDARD | PERMISSIVE |
| --------------------- | ------ | ------ | -------- | ---------- |
| timeout               | 5s     | 15s    | 30s      | 60s        |
| maxIterations         | 1,000  | 5,000  | 10,000   | 100,000    |
| maxToolCalls          | 10     | 50     | 100      | 1,000      |
| maxConsoleCalls       | 100    | 500    | 1,000    | 10,000     |
| maxConsoleOutputBytes | 64KB   | 256KB  | 1MB      | 10MB       |
| sanitizeStackTraces   | YES    | YES    | NO       | NO         |
| blockTimingAPIs       | YES    | NO     | NO       | NO         |
| allowUnboundedLoops   | NO     | NO     | YES      | YES        |
| unicodeSecurityCheck  | YES    | YES    | NO       | NO         |

<Warning>
  Use `STRICT` for any untrusted code, including AI-generated scripts from external sources or user-submitted scripts.
</Warning>

---

## Defense-in-Depth Security Model

Enclave uses a multi-layer security approach:

### Layer 1: AST Validation

Before any code runs, Enclave validates the AST using ast-guard's AgentScript preset:

```ts
// These are automatically blocked:
eval('code');                    // eval blocked
new Function('return 1')();       // Function constructor blocked
setTimeout(() => {}, 100);        // setTimeout blocked
process.exit();                   // process access blocked
window.location;                  // window access blocked
this.constructor;                 // this access blocked
```

The AgentScript preset blocks:

| Category                   | Blocked Constructs                                                 |
| -------------------------- | ------------------------------------------------------------------ |
| **Eval-like**              | `eval`, `Function`, `setTimeout`, `setInterval`                    |
| **Globals**                | `process`, `require`, `window`, `document`, `global`, `globalThis` |
| **Context access**         | `this`, `self`, `parent`, `top`, `frames`                          |
| **Prototype manipulation** | `__proto__`, `constructor`, `prototype` access                     |

### Layer 2: Code Transformation

Valid code is transformed for safe execution:

```ts
// Original code:
const users = await callTool('users:list', {});
for (const user of users) {
  console.log(user.name);
}

// Transformed code:
async function __ag_main() {
  const users = await __safe_callTool('users:list', {});
  __safe_forOf(users, (user) => {
    __safe_console.log(user.name);
  });
}
```

Transformations include:

- **Main wrapper**: Wrap code in `async function __ag_main()` for top-level await
- **Safe callTool**: Transform `callTool` to `__safe_callTool` (proxied through Enclave)
- **Safe loops**: Transform `for`, `while`, `do-while` to safe versions with iteration limits
- **Safe console**: Transform `console` to `__safe_console` (captured for logging with rate limiting)

### Layer 3: Runtime Sandboxing

Code executes in an isolated Node.js vm context:

- **Isolated context**: Fresh context with no access to host environment
- **Controlled globals**: Only whitelisted globals available (`Math`, `JSON`, `Array`, etc.)
- **Resource limits**: Timeout, iteration count, tool call limits, and console rate limits enforced
- **Stack sanitization**: Error stack traces sanitized to prevent information leakage

### Layer 4: Reference Sidecar (Optional)

When enabled, large data is handled separately:

- **Large data extraction**: Strings exceeding the threshold are stored in sidecar storage
- **Reference tokens**: Large strings are replaced with safe reference tokens (`__ref_abc123`)
- **Lazy resolution**: Data is only resolved when explicitly accessed
- **Composite blocking**: String concatenation with references can be blocked (`allowComposites: false`)

---

## Configuration Options

### Core Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `timeout` | number | 30000 | Maximum execution time in milliseconds |
| `maxToolCalls` | number | 100 | Maximum number of tool calls allowed per execution |
| `maxIterations` | number | 10000 | Maximum loop iterations allowed (prevents infinite loops) |
| `toolHandler` | function | - | Async function that handles `callTool()` invocations |
| `globals` | object | - | Additional globals to make available in the script context |
| `validate` | boolean | true | Whether to validate code with ast-guard before execution |
| `transform` | boolean | true | Whether to transform code before execution |

### Console Limits

| Option | Type | Description |
|--------|------|-------------|
| `maxConsoleOutputBytes` | number | Maximum total console output in bytes |
| `maxConsoleCalls` | number | Maximum number of console calls allowed |

### Reference Sidecar Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `sidecar.enabled` | boolean | false | Enable the sidecar feature for large data handling |
| `sidecar.maxTotalSize` | number | 10MB | Maximum total size of all stored references |
| `sidecar.maxReferenceSize` | number | 1MB | Maximum size of a single reference |
| `sidecar.extractionThreshold` | number | 1024 | Minimum string size to extract to sidecar |
| `sidecar.allowComposites` | boolean | false | Allow string concatenation with reference tokens |

---

## Double VM Layer

The Double VM layer provides enhanced security through nested VM isolation:

- **Parent VM**: Security barrier with operation validation
- **Inner VM**: Isolated execution environment for user code
- **Tool call flow**: Inner VM to Parent VM validation to Host handler

```typescript
const enclave = new Enclave({
  securityLevel: 'SECURE',
  doubleVm: {
    enabled: true, // Default: true
    parentTimeoutBuffer: 1000, // Extra timeout for parent VM (ms)
    parentValidation: {
      validateOperationNames: true,
      allowedOperationPattern: /^[a-z]+:[a-z]+$/i, // Optional whitelist
      blockedOperationPatterns: [/^admin:/i], // Blacklist patterns
      maxOperationsPerSecond: 100, // Rate limiting
      blockSuspiciousSequences: true, // Detect attack patterns
    },
  },
});
```

### Built-in Suspicious Pattern Detection

| Pattern | Description |
|---------|-------------|
| `EXFIL_LIST_SEND` | List/query followed by send/export |
| `RAPID_ENUMERATION` | Same operation called >10 times in 5s |
| `CREDENTIAL_EXFIL` | Credential access + external operation |
| `BULK_OPERATION` | Bulk/batch/mass operation names |
| `DELETE_AFTER_ACCESS` | Delete operation after data access |

### Custom Patterns

```typescript
const enclave = new Enclave({
  doubleVm: {
    parentValidation: {
      suspiciousPatterns: [
        {
          id: 'CUSTOM_PATTERN',
          description: 'Custom detection logic',
          detect: (operationName, args, history) => {
            return operationName.includes('dangerous');
          },
        },
      ],
    },
  },
});
```

---

## AI Scoring Gate

The Scoring Gate adds semantic security analysis that detects attack patterns beyond static AST validation:

- **Data exfiltration** - list followed by send or query followed by export sequences
- **Excessive access** - High limits, wildcard queries
- **Fan-out attacks** - Tool calls inside loops
- **Sensitive data access** - Passwords, tokens, PII fields

```ts
import { Enclave } from '@enclave-vm/core';

// Rule-based scorer (~1ms latency, zero dependencies)
const enclave = new Enclave({
  scoringGate: {
    scorer: 'rule-based',
    blockThreshold: 70,     // Score >= 70 blocks execution
    warnThreshold: 40,      // Score >= 40 logs warning
    failOpen: true,         // Allow if scoring fails (default)
  },
});

// External API scorer (best detection, ~100ms latency)
const enclaveWithApi = new Enclave({
  scoringGate: {
    scorer: 'external-api',
    externalApi: {
      endpoint: 'https://api.example.com/score',
      apiKey: process.env.SCORING_API_KEY,
      timeoutMs: 5000,
      retries: 1,
    },
  },
});
```

### Scorer Types

| Type           | Latency | Dependencies   | Detection |
| -------------- | ------- | -------------- | --------- |
| `disabled`     | 0ms     | None           | None      |
| `rule-based`   | ~1ms    | None           | Good      |
| `local-llm`    | ~5-10ms | Model download | Better    |
| `external-api` | ~100ms  | Network        | Best      |

### Detection Rules

| Rule              | Score | Description                            |
| ----------------- | ----- | -------------------------------------- |
| `SENSITIVE_FIELD` | 35    | Queries password/token/secret fields   |
| `EXCESSIVE_LIMIT` | 25    | limit > 10,000                         |
| `WILDCARD_QUERY`  | 20    | query="*" or filter={}                 |
| `LOOP_TOOL_CALL`  | 25    | callTool inside for/for-of loop        |
| `EXFIL_PATTERN`   | 50    | list followed by send or query followed by export sequence |
| `EXTREME_VALUE`   | 30    | Numeric arg > 1,000,000                |
| `DYNAMIC_TOOL`    | 20    | Variable tool name (not static string) |
| `BULK_OPERATION`  | 15    | Tool name contains bulk/batch/all      |

---

## Worker Pool Adapter

For OS-level memory isolation, use the worker threads adapter:

```ts
import { Enclave } from '@enclave-vm/core';

const enclave = new Enclave({
  adapter: 'worker_threads',
  workerPoolConfig: {
    minWorkers: 2,
    maxWorkers: 8,
    memoryLimitPerWorker: 256 * 1024 * 1024, // 256MB
  },
});
```

### Worker Pool Features

- **Pool management** - Auto-scaling with min/max workers
- **Memory monitoring** - Workers recycled when exceeding limits
- **Hard halt** - Force terminate via `worker.terminate()`
- **Rate limiting** - Message flood protection
- **Dual-layer sandbox** - Worker thread + VM context isolation

### Worker Pool Presets

| Setting                | STRICT | SECURE | STANDARD | PERMISSIVE |
| ---------------------- | ------ | ------ | -------- | ---------- |
| maxWorkers             | 4      | 8      | 16       | 32         |
| memoryLimitPerWorker   | 64MB   | 128MB  | 256MB    | 512MB      |
| maxExecutionsPerWorker | 100    | 500    | 1,000    | 5,000      |
| maxQueueSize           | 20     | 50     | 100      | 500        |
| maxMessagesPerSecond   | 100    | 500    | 1,000    | 5,000      |

---

## Memory Tracking & Limits

Setting the `memoryLimit` option instruments string and array allocations:

```typescript
import { Enclave } from '@enclave-vm/core';

const enclave = new Enclave({ memoryLimit: 32 * 1024 * 1024 });
const result = await enclave.execute(code);

if (!result.success && result.error?.code === 'MEMORY_LIMIT_EXCEEDED') {
  console.warn(
    `Script used ${result.error.data.usedBytes} bytes (limit ${result.error.data.limitBytes})`,
  );
}

console.log(`Peak tracked memory: ${result.stats.memoryUsage} bytes`);
```

For advanced scenarios you can instantiate the tracker directly:

```typescript
import { MemoryTracker } from '@enclave-vm/core';

const tracker = new MemoryTracker({ memoryLimit: 10 * 1024 * 1024 });
tracker.start();
```

---

## Reference Sidecar

The sidecar handles large data in AgentScript without embedding it in the script:

### How It Works

1. **Extraction**: When a tool returns data with large strings (> `extractionThreshold`), those strings are stored in the sidecar and replaced with reference tokens (`__ref_abc123`)
2. **Lazy Resolution**: When script code accesses a reference token, it's resolved just-in-time to the actual data
3. **Safe Property Access**: Only explicit property accesses trigger resolution, preventing data exfiltration

```ts
const enclave = new Enclave({
  toolHandler: async (name, args) => {
    if (name === 'documents:get') {
      // Returns a 2MB document - automatically stored in sidecar
      return { content: '...2MB of text...' };
    }
  },
  sidecar: {
    enabled: true,
    extractionThreshold: 1024,    // Extract strings > 1KB
    allowComposites: false,        // Block: ref + "_suffix" (security)
  },
});

const result = await enclave.run(`
  const doc = await callTool('documents:get', { id: 'doc-123' });
  // doc.content is a reference token, resolved on access
  return { wordCount: doc.content.split(' ').length };
`);
```

---

## Execution Results

Enclave returns a structured result with success/error status and execution stats:

```ts
interface ExecutionResult<T> {
  success: boolean;
  value?: T;              // Result value (if success)
  error?: {               // Error details (if failed)
    name: string;
    message: string;
    code: string;
    stack?: string;
  };
  stats: {
    duration: number;      // Execution time in ms
    toolCallCount: number; // Number of tool calls made
    iterationCount: number; // Number of loop iterations
  };
}
```

### Error Codes

| Code               | Meaning                    | Action                                |
| ------------------ | -------------------------- | ------------------------------------- |
| `VALIDATION_ERROR` | AST validation failed      | Fix the code - blocked construct used |
| `EXECUTION_ERROR`  | Runtime error in script    | Fix script logic                      |
| `TIMEOUT`          | Execution exceeded timeout | Optimize or increase timeout          |
| `TOOL_ERROR`       | Tool call failed           | Check tool input/availability         |
| `MEMORY_LIMIT_EXCEEDED` | Memory limit exceeded | Reduce memory usage or increase limit |

---

## Advanced Usage

### Custom Globals

Provide custom globals for scripts to access:

```ts
const enclave = new Enclave({
  toolHandler: async (name, args) => { /* ... */ },
  globals: {
    // Custom read-only context
    context: {
      userId: 'user-123',
      tenantId: 'tenant-456',
    },
    // Custom utility function
    formatDate: (date: Date) => date.toISOString(),
  },
});

const code = `
  const userId = context.userId;
  const timestamp = formatDate(new Date());
  return { userId, timestamp };
`;

const result = await enclave.run(code);
```

### One-Shot Execution

For simple cases, use the convenience function:

```ts
import { runAgentScript } from '@enclave-vm/core';

const result = await runAgentScript(`
  return Math.max(1, 2, 3);
`, {
  timeout: 1000,
});

console.log(result.value); // 3
```

### Tool Handler Integration

Integrate with your existing tool system:

```ts
import { Enclave } from '@enclave-vm/core';
import { ToolRegistry } from './tools';

const enclave = new Enclave({
  timeout: 10000,
  toolHandler: async (toolName, args) => {
    // Look up tool in registry
    const tool = ToolRegistry.get(toolName);
    if (!tool) {
      throw new Error(`Unknown tool: ${toolName}`);
    }

    // Execute with your pipeline (auth, logging, etc.)
    return tool.execute(args);
  },
});
```

---

## Security Considerations

<Warning>
  While Enclave provides strong security guarantees, it should be used as part of a defense-in-depth strategy. Always:
  - Validate tool inputs before execution
  - Limit what tools are available to scripts
  - Monitor execution for anomalies
  - Keep Enclave and ast-guard updated
</Warning>

### What Enclave Protects Against

- **Code injection** - Blocked by AST validation
- **Infinite loops** - Limited by `maxIterations`
- **Resource exhaustion** - Limited by `timeout` and `maxToolCalls`
- **I/O flood attacks** - Limited by `maxConsoleOutputBytes` and `maxConsoleCalls`
- **Global access** - Blocked by AST validation and isolated context
- **Prototype pollution** - Blocked by AST validation
- **Information leakage** - Stack traces sanitized

### What Enclave Does NOT Protect Against

- **Tool abuse** - Scripts can call allowed tools; limit what's available
- **Algorithmic complexity** - Scripts can run O(n^2) algorithms within limits
- **Memory exhaustion** - Large arrays/objects within timeout
- **Side effects** - Tool calls have real effects; use read-only tools where possible

## Links

- [GitHub](https://github.com/agentfront/enclave/tree/main/libs/core)
- [npm](https://www.npmjs.com/package/@enclave-vm/core)
- [ast-guard Documentation](/libraries/ast-guard)
