---
title: 'Persistence'
description: 'Storage adapters for persisting embeddings between restarts'
---

Avoid re-indexing on every boot by using storage adapters. VectoriaDB supports file, Redis, and in-memory storage.

## Storage Adapters

| Adapter | Use Case | Persistence |
|---------|----------|-------------|
| `MemoryStorageAdapter` | Development, testing | None (default) |
| `FileStorageAdapter` | Single-server deployment | Local disk |
| `RedisStorageAdapter` | Multi-pod deployment | Shared cache |

## File Adapter

Persist embeddings to local disk:

```ts
import { VectoriaDB, FileStorageAdapter, createToolsHash } from 'vectoriadb';

const documents = collectToolDocuments();

const toolIndex = new VectoriaDB<ToolDocument>({
  storageAdapter: new FileStorageAdapter({
    cacheDir: './.cache/vectoriadb',
    namespace: 'tool-index',
  }),
  toolsHash: createToolsHash(documents),
  version: process.env.npm_package_version,
});

await toolIndex.initialize();

if (toolIndex.size() === 0) {
  await toolIndex.addMany(documents);
  await toolIndex.saveToStorage(); // Persist to disk
}
```

### File Adapter Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `cacheDir` | string | `./.cache/vectoriadb` | Directory for cache files |
| `namespace` | string | `'default'` | Namespace for isolation |

## Redis Adapter

For multi-pod environments, use Redis to share embeddings:

```ts
import { VectoriaDB, RedisStorageAdapter } from 'vectoriadb';
import Redis from 'ioredis';

const redisClient = new Redis();

const toolIndex = new VectoriaDB<ToolDocument>({
  storageAdapter: new RedisStorageAdapter({
    client: redisClient,
    namespace: 'tool-index',
    ttl: 86400,        // 24 hours (default)
    keyPrefix: 'vectoriadb',
  }),
});

await toolIndex.initialize();

if (toolIndex.size() === 0) {
  await toolIndex.addMany(documents);
  await toolIndex.saveToStorage();
}
```

### Redis Adapter Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `client` | Redis | required | ioredis client instance |
| `namespace` | string | `'default'` | Namespace for isolation |
| `ttl` | number | `86400` | Time-to-live in seconds |
| `keyPrefix` | string | `'vectoriadb'` | Redis key prefix |

## Memory Adapter (Default)

No persistence - embeddings are lost on restart:

```ts
import { VectoriaDB, MemoryStorageAdapter } from 'vectoriadb';

const toolIndex = new VectoriaDB<ToolDocument>({
  storageAdapter: new MemoryStorageAdapter({ namespace: 'tools' }),
});
```

Use for development or when re-indexing is fast enough.

## Cache Invalidation

VectoriaDB automatically invalidates the cache when documents change. Use `toolsHash` and `version` to control invalidation:

```ts
const toolIndex = new VectoriaDB<ToolDocument>({
  storageAdapter: new FileStorageAdapter({ cacheDir: './.cache' }),

  // Hash of document contents - invalidates when documents change
  toolsHash: createToolsHash(documents),

  // Application version - invalidates on deployments
  version: process.env.npm_package_version,
});
```

### How Invalidation Works

On `initialize()`, VectoriaDB checks:
1. Does the cache file/key exist?
2. Does `toolsHash` match?
3. Does `version` match?
4. Does `modelName` match?

If any check fails, the cache is invalidated and re-indexing occurs.

## Warm-up Pattern

Common pattern for production deployments:

```ts
export async function warmToolIndex(documents: ToolDocument[]) {
  const toolIndex = new VectoriaDB<ToolDocument>({
    storageAdapter: new FileStorageAdapter({
      cacheDir: './.cache/vectoriadb',
      namespace: 'tool-index',
    }),
    toolsHash: createToolsHash(documents),
    version: process.env.npm_package_version,
  });

  await toolIndex.initialize();

  // Only re-index if cache was invalidated
  if (toolIndex.size() === 0) {
    console.log('Cache miss - re-indexing...');
    await toolIndex.addMany(documents);
    await toolIndex.saveToStorage();
  } else {
    console.log('Cache hit - loaded from storage');
  }

  return toolIndex;
}
```

## Manual Storage Operations

```ts
// Save current state to storage
await toolIndex.saveToStorage();

// Load from storage (done automatically on initialize)
await toolIndex.loadFromStorage();

// Clear storage
await toolIndex.clearStorage();
```

## Multi-Tenant Isolation

Use namespaces to isolate different indexes:

```ts
// Tenant A
const tenantAIndex = new VectoriaDB({
  storageAdapter: new RedisStorageAdapter({
    client: redisClient,
    namespace: 'tenant-a',
  }),
});

// Tenant B
const tenantBIndex = new VectoriaDB({
  storageAdapter: new RedisStorageAdapter({
    client: redisClient,
    namespace: 'tenant-b',
  }),
});
```

## Error Handling

```ts
import { StorageError } from 'vectoriadb';

try {
  await toolIndex.saveToStorage();
} catch (error) {
  if (error instanceof StorageError) {
    console.error('Storage operation failed:', error.message);
    // Fallback to in-memory only
  }
}
```

## Related

- [Overview](/core-libraries/vectoriadb/overview) - Getting started
- [HNSW](/core-libraries/vectoriadb/hnsw) - Scaling with HNSW index
- [Indexing](/core-libraries/vectoriadb/indexing) - Adding documents
