---
title: 'Indexing'
description: 'Adding and updating documents in VectoriaDB'
---

Add documents with a unique `id`, the natural-language `text` to vectorize, and typed `metadata`.

## Adding Documents

### Single Document

```ts
await toolIndex.add('users:list', 'List all users with pagination and filtering', {
  id: 'users:list',
  toolName: 'list',
  owner: 'users',
  tags: ['read', 'user-management'],
  risk: 'safe',
});
```

### Batch Indexing

```ts
const documents = [
  {
    id: 'billing:charge',
    text: 'Charge a customer payment method',
    metadata: {
      id: 'billing:charge',
      toolName: 'charge',
      owner: 'billing',
      tags: ['write', 'payment'],
      risk: 'destructive',
    },
  },
  {
    id: 'billing:refund',
    text: 'Process a refund for a customer',
    metadata: {
      id: 'billing:refund',
      toolName: 'refund',
      owner: 'billing',
      tags: ['write', 'payment'],
      risk: 'destructive',
    },
  },
];

await toolIndex.addMany(documents);
```

`addMany` validates every document, enforces `maxBatchSize`, and prevents duplicates.

## Type-Safe Metadata

Define your metadata interface for compile-time safety:

```ts
import { VectoriaDB, DocumentMetadata } from 'vectoriadb';

interface ToolDocument extends DocumentMetadata {
  toolName: string;
  owner: string;
  tags: string[];
  risk: 'safe' | 'destructive';
  deprecated?: boolean;
}

const db = new VectoriaDB<ToolDocument>();

// TypeScript ensures metadata matches interface
await db.add('id', 'text', {
  id: 'id',
  toolName: 'test',
  owner: 'system',
  tags: [],
  risk: 'safe',
  // TypeScript error if you add wrong fields
});
```

## Updating Documents

### Update Metadata Only

Metadata-only updates are instant and don't trigger re-embedding:

```ts
await toolIndex.updateMetadata('users:list', {
  deprecated: true,
  tags: ['read', 'user-management', 'legacy'],
});
```

### Update Text and Metadata

When text changes, VectoriaDB re-embeds the document:

```ts
await toolIndex.update('users:list', {
  text: 'Updated description for user listing',
  metadata: {
    id: 'users:list',
    toolName: 'list',
    owner: 'users',
    tags: ['read'],
    risk: 'safe',
  },
});
```

### Batch Updates

```ts
await toolIndex.updateMany([
  {
    id: 'users:list',
    text: 'New description',
    metadata: { /* ... */ },
  },
  {
    id: 'billing:charge',
    metadata: { deprecated: true }, // Metadata-only update
  },
]);
```

<Tip>
  Keep the index current with `updateMetadata`, `update`, or `updateMany`. Metadata-only updates never trigger re-embedding, while text changes re-embed only the affected documents.
</Tip>

## Removing Documents

```ts
// Single document
await toolIndex.remove('users:list');

// Multiple documents
await toolIndex.removeMany(['users:list', 'billing:charge']);

// Clear all documents
await toolIndex.clear();
```

## Checking for Documents

```ts
// Check if document exists
const exists = toolIndex.has('users:list');

// Get document by ID
const doc = toolIndex.get('users:list');
if (doc) {
  console.log(doc.metadata.toolName);
}

// Get count
console.log(`Index contains ${toolIndex.size()} documents`);
```

## Document Limits

VectoriaDB enforces limits to prevent DoS attacks:

```ts
const db = new VectoriaDB({
  maxDocuments: 100000,    // Maximum documents in index
  maxDocumentSize: 1000000, // Maximum text size in characters
  maxBatchSize: 1000,      // Maximum documents per batch operation
});
```

## Embedding Generation

Embeddings are generated automatically when you add or update documents. The process:

1. Text is tokenized using the configured model
2. Embeddings are generated (~100-200 documents/second)
3. Embeddings are stored in memory (and optionally persisted)

For large imports, use `addMany` with appropriate `maxBatchSize` to avoid memory spikes.

## Related

- [Search](/core-libraries/vectoriadb/search) - Querying the index
- [Persistence](/core-libraries/vectoriadb/persistence) - Persisting embeddings
- [Overview](/core-libraries/vectoriadb/overview) - Getting started
