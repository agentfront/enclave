---
title: 'vectoriadb'
description: 'Lightweight in-memory vector database for semantic search with offline embeddings and production-ready guardrails'
---

# vectoriadb

VectoriaDB is a production-ready in-memory vector database built on transformers.js. Use it to surface the right tool, prompt, or document snippet from natural-language queries without shipping data to an external service.

<CardGroup cols={3}>
  <Card title="Offline Embeddings" icon="bolt">
    Embeddings run locally via transformers.js, so your data never leaves the server and you avoid API quotas.
  </Card>
  <Card title="Type-safe Metadata" icon="brackets-curly">
    Strong generics ensure every document you index keeps the same shape as your tool metadata.
  </Card>
  <Card title="Operational Guardrails" icon="shield">
    Built-in rate limits, batch validation, HNSW indexing, and storage adapters keep the index production ready.
  </Card>
</CardGroup>

## When to Use VectoriaDB

- **Tool discovery** - Surface the right tool from natural-language queries
- **Document search** - Semantic search over documents, prompts, or code snippets
- **Recommendation systems** - Find similar items based on text embeddings
- **Offline-first applications** - No external API dependencies

<Note>
  The default Xenova `all-MiniLM-L6-v2` model is ~22 MB. The first initialization downloads and caches it under `cacheDir`; subsequent boots reuse the local copy.
</Note>

## Installation

```bash
npm install vectoriadb
```

## Quick Start

```ts
import { VectoriaDB, DocumentMetadata } from 'vectoriadb';

interface ToolDocument extends DocumentMetadata {
  toolName: string;
  owner: string;
  tags: string[];
  risk: 'safe' | 'destructive';
}

const toolIndex = new VectoriaDB<ToolDocument>({
  cacheDir: './.cache/transformers',
  defaultSimilarityThreshold: 0.4,
});

await toolIndex.initialize(); // downloads and warms the embedding model once
```

`initialize()` must run before `add`, `search`, or `update`. Calling it twice is safe because VectoriaDB short-circuits if it is already ready.

---

## Indexing Documents

Add documents with a unique `id`, the natural-language `text` to vectorize, and typed `metadata`:

```ts
// Single document
await toolIndex.add('users:list', 'List all users with pagination and filtering', {
  id: 'users:list',
  toolName: 'list',
  owner: 'users',
  tags: ['read', 'user-management'],
  risk: 'safe',
});

// Batch indexing
const documents = [
  {
    id: 'billing:charge',
    text: 'Charge a customer payment method',
    metadata: {
      id: 'billing:charge',
      toolName: 'charge',
      owner: 'billing',
      tags: ['write', 'payment'],
      risk: 'destructive',
    },
  },
  // ... more documents
];

await toolIndex.addMany(documents);
```

`addMany` validates every document, enforces `maxBatchSize`, and prevents duplicates.

<Tip>
  Keep the index current with `updateMetadata`, `update`, or `updateMany`. Metadata-only updates never trigger re-embedding, while text changes re-embed only the affected documents.
</Tip>

---

## Semantic Search

Query the index with natural language and optional filters:

```ts
const matches = await toolIndex.search('reset a billing password', {
  topK: 5,
  threshold: 0.45,
  filter: (metadata) => metadata.owner === 'billing' && !metadata.tags.includes('deprecated'),
});

for (const match of matches) {
  console.log(`${match.metadata.toolName} (${match.score.toFixed(2)})`);
}
```

### Search Options

| Option          | Type       | Default | Description                          |
| --------------- | ---------- | ------- | ------------------------------------ |
| `topK`          | `number`   | `10`    | Maximum results to return            |
| `threshold`     | `number`   | `0.3`   | Minimum similarity score             |
| `filter`        | `function` | -       | Filter function for metadata         |
| `includeVector` | `boolean`  | `false` | Include raw vectors in results       |

---

## Persistence

Avoid re-indexing on every boot by using storage adapters.

### File Adapter

```ts
import { VectoriaDB, FileStorageAdapter, createToolsHash } from 'vectoriadb';

const toolIndex = new VectoriaDB<ToolDocument>({
  storageAdapter: new FileStorageAdapter({
    cacheDir: './.cache/vectoriadb',
    namespace: 'tool-index',
  }),
  toolsHash: createToolsHash(documents),
  version: process.env.npm_package_version,
});

await toolIndex.initialize();

if (toolIndex.size() === 0) {
  await toolIndex.addMany(documents);
  await toolIndex.saveToStorage(); // persist embeddings to disk
}
```

`toolsHash` automatically invalidates the cache when your document list or descriptions change.

### Redis Adapter

For multi-pod environments, use Redis to share embeddings:

```ts
import { VectoriaDB, RedisStorageAdapter } from 'vectoriadb';
import Redis from 'ioredis';

const redisClient = new Redis();

const toolIndex = new VectoriaDB<ToolDocument>({
  storageAdapter: new RedisStorageAdapter({
    client: redisClient,
    namespace: 'tool-index',
    ttl: 86400,        // 24 hours (default)
    keyPrefix: 'vectoriadb',
  }),
});
```

### Memory Adapter (Default)

No persistence - embeddings are lost on restart:

```ts
import { VectoriaDB, MemoryStorageAdapter } from 'vectoriadb';

const toolIndex = new VectoriaDB<ToolDocument>({
  storageAdapter: new MemoryStorageAdapter({ namespace: 'tools' }),
});
```

---

## HNSW Indexing

Enable HNSW (Hierarchical Navigable Small World) for datasets above roughly 10,000 documents. HNSW provides sub-millisecond queries with more than 95% recall.

```ts
const toolIndex = new VectoriaDB<ToolDocument>({
  useHNSW: true,
  hnsw: { M: 16, efConstruction: 200, efSearch: 64 },
  maxDocuments: 150_000,
  maxBatchSize: 2_000,
});
```

### HNSW Configuration

| Option           | Default | Description                                                |
| ---------------- | ------- | ---------------------------------------------------------- |
| `M`              | 16      | Connections per node in layer > 0 (higher = better recall) |
| `M0`             | 32      | Connections for layer 0 (typically M Ã— 2)                  |
| `efConstruction` | 200     | Candidate list size during construction                    |
| `efSearch`       | 50      | Candidate list size during search                          |

---

## Complete Configuration Options

| Option                       | Type      | Default                     | Description                    |
| ---------------------------- | --------- | --------------------------- | ------------------------------ |
| `modelName`                  | `string`  | `'Xenova/all-MiniLM-L6-v2'` | Embedding model to use         |
| `cacheDir`                   | `string`  | `'./.cache/transformers'`   | Model cache directory          |
| `dimensions`                 | `number`  | Auto-detected               | Vector dimensions              |
| `defaultSimilarityThreshold` | `number`  | `0.3`                       | Minimum similarity score       |
| `defaultTopK`                | `number`  | `10`                        | Default results limit          |
| `useHNSW`                    | `boolean` | `false`                     | Enable HNSW index              |
| `maxDocuments`               | `number`  | `100000`                    | Max documents (DoS protection) |
| `maxDocumentSize`            | `number`  | `1000000`                   | Max document size in chars     |
| `maxBatchSize`               | `number`  | `1000`                      | Max batch operation size       |
| `verboseErrors`              | `boolean` | `true`                      | Enable detailed errors         |

---

## TF-IDF Variant (Zero Dependencies)

For scenarios where ML model downloads aren't acceptable, use the TF-IDF variant:

```ts
import { TFIDFVectoria } from 'vectoriadb';

interface ToolDocument extends DocumentMetadata {
  toolName: string;
  category: string;
}

const db = new TFIDFVectoria<ToolDocument>({
  defaultSimilarityThreshold: 0.0,
  defaultTopK: 10,
});

// Add documents
db.addDocument('tool1', 'User authentication tool', { id: 'tool1', toolName: 'auth', category: 'security' });
db.addDocument('tool2', 'User profile retrieval', { id: 'tool2', toolName: 'profile', category: 'user' });

// Reindex after adding documents (required for IDF update)
db.reindex();

// Search
const results = db.search('authentication', { topK: 5 });
```

### When to Use TF-IDF vs ML Embeddings

| Feature                | TFIDFVectoria                  | VectoriaDB                    |
| ---------------------- | ------------------------------ | ----------------------------- |
| Dependencies           | Zero                           | transformers.js (~22MB model) |
| Initialization         | Synchronous                    | Async (model download)        |
| Semantic understanding | Keyword-based                  | Full semantic                 |
| Best for               | Small corpora (under 10K docs) | Any size                      |
| Reindex required       | Yes, after changes             | No                            |

---

## Error Handling

All errors extend `VectoriaError` and include machine-readable `code` values:

| Error                         | Code                        | Description                |
| ----------------------------- | --------------------------- | -------------------------- |
| `VectoriaNotInitializedError` | `NOT_INITIALIZED`           | Call `initialize()` first  |
| `DocumentValidationError`     | `DOCUMENT_VALIDATION_ERROR` | Invalid document data      |
| `DocumentNotFoundError`       | `DOCUMENT_NOT_FOUND`        | Document ID doesn't exist  |
| `DocumentExistsError`         | `DOCUMENT_EXISTS`           | Document ID already exists |
| `DuplicateDocumentError`      | `DUPLICATE_DOCUMENT`        | Duplicate in batch         |
| `QueryValidationError`        | `QUERY_VALIDATION_ERROR`    | Invalid search query       |
| `EmbeddingError`              | `EMBEDDING_ERROR`           | Model embedding failed     |
| `StorageError`                | `STORAGE_ERROR`             | Storage operation failed   |
| `ConfigurationError`          | `CONFIGURATION_ERROR`       | Invalid config             |

```ts
import {
  VectoriaError,
  VectoriaNotInitializedError,
  DocumentValidationError,
} from 'vectoriadb';

try {
  await toolIndex.add(doc.id, doc.text, doc.metadata);
} catch (error) {
  if (error instanceof VectoriaNotInitializedError) {
    await toolIndex.initialize();
  } else if (error instanceof DocumentValidationError) {
    console.warn({ tool: error.documentId }, 'invalid document skipped');
  } else if (error instanceof VectoriaError) {
    console.error({ code: error.code }, error.message);
    throw error;
  } else {
    throw error;
  }
}
```

---

## Monitoring & Stats

Use `getStats()` to feed dashboards or health endpoints:

```ts
const stats = toolIndex.getStats();
/*
{
  totalEmbeddings: number;
  dimensions: number;
  estimatedMemoryBytes: number;
  modelName: string;
}
*/
```

<Info>
  Pair stats with `toolIndex.size()`, `toolIndex.clear()`, and `toolIndex.clearStorage()` for maintenance commands or admin tooling.
</Info>

## Links

- [GitHub](https://github.com/agentfront/enclave/tree/main/libs/vectoriadb)
- [npm](https://www.npmjs.com/package/vectoriadb)
